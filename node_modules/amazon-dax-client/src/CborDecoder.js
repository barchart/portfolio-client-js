/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not
 * use this file except in compliance with the License. A copy of the License
 * is located at
 *
 *    http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
'use strict';
const TransformStream = require('stream').Transform;
const StreamBuffer = require('./ByteStreamBuffer');
const BigNumber = require('bignumber.js');
const BigDecimal = require('./BigDecimal');
const CborTypes = require('./CborTypes');
const DaxClientError = require('./DaxClientError');
const DaxErrorCode = require('./DaxErrorCode');
const Util = require('./Util');

const SHIFT32 = Math.pow(2, 32);
const EMPTY_BUF = Buffer.alloc(0);

class CborDecoder extends TransformStream {
  constructor(options) {
    super(options);
    this._readableState.objectMode = true;
    this._buffer = new StreamBuffer();
    this._retBuffer = new StreamBuffer();
    this._restart();
  }

  static decodeAllSync(input) {
    sharedSyncMethodBuf.write(input);
    const res = [];
    while(sharedSyncMethodBuf.length > 0) {
      const parser = sharedSyncMethodDecoder._parse(res);
      let state = parser.next();
      while(!state.done) {
        const b = sharedSyncMethodBuf.read(state.value);
        if((b == null) || (b.length !== state.value)) {
          throw new DaxClientError(`Insufficient data: ${b}`, DaxErrorCode.Decoder);
        }
        state = parser.next(b);
      }
    }
    return res;
  }

  static decodePartialSync(input, ref, n) {
    const length = input.length;
    sharedSyncMethodBuf.write(input);
    const res = [];
    while(sharedSyncMethodBuf.length > 0) {
      const parser = sharedSyncMethodDecoder._parse(res);
      let state = parser.next();
      ref.offset = length - sharedSyncMethodBuf.length;
      if(n && res.length >= n) {
        // If the caller limited the number of results, stop here
        sharedSyncMethodBuf.read();
        return res;
      }
      while(!state.done) {
        const b = sharedSyncMethodBuf.read(state.value);
        if((b == null) || (b.length !== state.value)) {
          // failed to decode CBOR, so return the good parts and the offset
          sharedSyncMethodBuf.read();
          return res;
        }
        state = parser.next(b);
      }
    }
    return res;
  }

  _transform(data, encoding, callback) {
    this._buffer.write(data);
    while(this._buffer.length >= this._need) {
      let ret;
      let chunk = this._need === null
        ? undefined
        : this._buffer.read(this._need);
      try {
        ret = this._parser.next(chunk);
      } catch(e) {
        return callback(e);
      }

      if(this._need) {
        this._fresh = false;
      }

      if(!ret.done) {
        this._need = ret.value | 0;
      } else {
        this._restart();
      }
    }

    callback();
  }

  _restart() {
    this._need = null;
    this._parser = this._parse();
    this._fresh = true;

    this._mFieldType = -1;
    this._mFieldValue = 0;
  }

  _flush(callback) {
    callback(this._fresh ? null : new DaxClientError('unexpected end of input', DaxErrorCode.Decoder));
  }

  _consumeField() {
    this._mFieldType = -1;
  }

  static _parseHalf(buf) {
    let sign = buf[0] & 0x80 ? -1 : 1;
    let exp = (buf[0] & 0x7C) >> 2;
    let mant = ((buf[0] & 0x03) << 8) | buf[1];
    if(!exp) {
      return sign * 5.9604644775390625e-8 * mant;
    } else if(exp === 0x1f) {
      return sign * (mant ? 0 / 0 : 2e308);
    } else {
      return sign * Math.pow(2, exp - 25) * (1024 + mant);
    }
  }

  static _parseCBORint(ai, buf) {
    switch(ai) {
      case CborTypes.SIZE_8:
        return buf.readUInt8(0, true);
      case CborTypes.SIZE_16:
        return buf.readUInt16BE(0, true);
      case CborTypes.SIZE_32:
        return buf.readUInt32BE(0, true);
      case CborTypes.SIZE_64:
        let f = buf.readUInt32BE(0);
        let g = buf.readUInt32BE(4);
        return (f * SHIFT32) + g;
      default:
        throw new DaxClientError('Invalid additional info for int: ' + ai, DaxErrorCode.Decoder);
    }
  }

  * _readInt() {
    let type = yield* this._readType();
    let val = this._mFieldValue;
    switch(type >> 5) {
      case CborTypes.TYPE_POSINT >> 5:
        this._consumeField();
        return CborDecoder.convertByteToNumString(val);
      case CborTypes.TYPE_NEGINT >> 5:
        this._consumeField();
        return CborDecoder.convertByteToNumString(val, true);
    }
  }

  static convertByteToNumString(buf, isNeg) {
    if(buf.length >= 4 && (buf[buf.length - 4] & 0x80)) {
      if(isNeg) {
        return new BigNumber(Util.convertBase(buf.toString('hex'), 16, 10)).neg().sub(1).toString();
      } else {
        return Util.convertBase(buf.toString('hex'), 16, 10);
      }
    }

    if(buf.length > 4) {
      // SIZE_64
      let highByteNum = 0;
      for(let i = 0; i < 4; ++i) {
        highByteNum <<= 8;
        highByteNum += buf[i];
      }
      let lowByteNum = 0;
      for(let i = 4; i < buf.length; ++i) {
        lowByteNum <<= 8;
        lowByteNum += buf[i];
      }
      let bignum = new BigNumber(highByteNum).mul(SHIFT32).add(lowByteNum);
      if(isNeg) {
        return bignum.neg().sub(1).toString();
      } else {
        return bignum.toString();
      }
    } else {
      let num = 0;
      for(let i = 0; i < buf.length; ++i) {
        num <<= 8;
        num += buf[i];
      }
      if(isNeg) {
        num = ~num;
      }
      return num + '';
    }
  }

  * _readFloat() {
    this._consumeField();
    return CborDecoder._parseCBORfloat(this._mFieldValue) + '';
  }

  static _parseCBORfloat(buf) {
    switch(buf.length) {
      case 2:
        return CborDecoder._parseHalf(buf);
      case 4:
        return buf.readFloatBE(0, true);
      case 8:
        return buf.readDoubleBE(0, true);
      default:
        throw new DaxClientError('Invalid float size: ' + buf.length, DaxErrorCode.Decoder);
    }
  }

  * _readBigInt() {
    yield* this._readType();
    const tag = this._mFieldValue;
    this._consumeField();
    yield* this._readBinary();
    let buf = this._retBuffer.read();
    buf = buf ? buf : EMPTY_BUF;
    switch(tag) {
      case CborTypes.TAG_POSBIGINT:
        return new BigNumber(buf.toString('hex'), 16);
      case CborTypes.TAG_NEGBIGINT:
        return new BigNumber(buf.toString('hex'), 16).neg().sub(1);
      default:
        throw new DaxClientError('unsupported tag for BigInt', DaxErrorCode.Decoder);
    }
  }

  * _readBigDecimal() {
    yield* this._readType();
    const tag = this._mFieldValue;
    this._consumeField();
    yield* this._readType(); // read array header
    if(this._mFieldValue !== 2) {
      throw new DaxClientError('not correct form of BigDecimal, should be array of length 2', DaxErrorCode.Decoder);
    }
    this._consumeField();
    let scale = yield* this._readInt();
    let ustype = yield* this._readType();
    let bi;
    switch(ustype >> 5) {
      case CborTypes.TYPE_POSINT >> 5:
      case CborTypes.TYPE_NEGINT >> 5:
        bi = new BigNumber(yield* this._readInt());
        break;
      case CborTypes.TYPE_TAG >> 5:
        switch(ustype & CborTypes.MINOR_TYPE_MASK) {
          case CborTypes.TAG_POSBIGINT:
          case CborTypes.TAG_NEGBIGINT:
            bi = yield* this._readBigInt();
            break;
          default:
            throw new DaxClientError('incorrect data for BigDecimal', DaxErrorCode.Decoder);
        }
        break;
      default:
        throw new DaxClientError('incorrect data for BigDecimal', DaxErrorCode.Decoder);
    }
    switch(tag) {
      case CborTypes.TAG_DECIMAL:
        return new BigDecimal(bi, -scale);
      case CborTypes.TAG_BIGFLOAT:
      default:
        throw new DaxClientError('unsupported tag for BigDecimal', DaxErrorCode.Decoder);
    }
  }

  * _readStringAsBuffer() {
    let type = yield* this._readType();
    if((type >> 5) !== (CborTypes.TYPE_UTF >> 5)) {
      throw new DaxClientError('not a String to read', DaxErrorCode.Decoder);
    }
    this._consumeField();
    if((type & CborTypes.MINOR_TYPE_MASK) === CborTypes.SIZE_STREAM) {
      while((yield* this._readType()) !== CborTypes.TYPE_BREAK) {
        yield* this._readStringAsBuffer();
      }
      this._consumeField();
    } else {
      let buf = yield this._mFieldValue;
      if(buf) {
        this._retBuffer.write(buf);
      }
    }
  }

  * _readString() {
    yield* this._readStringAsBuffer();
  }

  * _readBinary() {
    let type = yield* this._readType();
    if((type >> 5) !== (CborTypes.TYPE_BYTES >> 5)) {
      throw new DaxClientError('not a Binary to read', DaxErrorCode.Decoder);
    }
    this._consumeField();
    if((type & CborTypes.MINOR_TYPE_MASK) === CborTypes.SIZE_STREAM) {
      while((yield* this._readType()) !== CborTypes.TYPE_BREAK) {
        yield* this._readBinary();
      }
      this._consumeField();
    } else {
      let buf = yield this._mFieldValue;
      if(buf) {
        this._retBuffer.write(buf);
      }
    }
  }

  * _readArray(sync) {
    let ret;
    if(sync) {
      ret = sync;
    } else {
      ret = this;
    }
    let type = yield* this._readType();
    if((type >> 5) !== (CborTypes.TYPE_ARRAY >> 5)) {
      throw new DaxClientError('not a Array to read', DaxErrorCode.Decoder);
    }
    this._consumeField();
    if((type & CborTypes.MINOR_TYPE_MASK) === CborTypes.SIZE_STREAM) {
      while((yield* this._readType()) !== CborTypes.TYPE_BREAK) {
        yield* this._readObject(sync);
      }
      this._consumeField();
      ret.push([CborTypes.RET_STREAM_BREAK]);
    } else {
      let len = this._mFieldValue;
      for(let i = 0; i < len; ++i) {
        yield* this._readObject(sync);
      }
    }
  }

  * _readMap(sync) {
    let ret;
    if(sync) {
      ret = sync;
    } else {
      ret = this;
    }
    let type = yield* this._readType();
    if((type >> 5) !== (CborTypes.TYPE_MAP >> 5)) {
      throw new DaxClientError('not a Map to read', DaxErrorCode.Decoder);
    }
    this._consumeField();
    if((type & CborTypes.MINOR_TYPE_MASK) === CborTypes.SIZE_STREAM) {
      while((yield* this._readType()) !== CborTypes.TYPE_BREAK) {
        yield* this._readObject(sync); // key
        yield* this._readObject(sync); // value
      }
      this._consumeField();
      ret.push([CborTypes.RET_STREAM_BREAK]);
    } else {
      let len = this._mFieldValue;
      for(let i = 0; i < len; ++i) {
        yield* this._readObject(sync); // key
        yield* this._readObject(sync); // value
      }
    }
  }

  * _readObject(sync) {
    let ret = sync || this;
    let isUnknownTag = false;
    let buf;
    do {
      // if is unknownTag, then will keep asking for another data since
      // unknown tag doesn't count for one solid data for array or map
      isUnknownTag = false;
      let type = yield* this._readType();
      switch(type >> 5) {
        case CborTypes.TYPE_POSINT >> 5:
        case CborTypes.TYPE_NEGINT >> 5:
          ret.push([CborTypes.RET_INT, yield* this._readInt()]);
          break;
        case CborTypes.TYPE_BYTES >> 5:
          yield* this._readBinary();
          buf = this._retBuffer.read();
          ret.push([CborTypes.RET_BUF, buf ? buf : EMPTY_BUF]);
          break;
        case CborTypes.TYPE_UTF >> 5:
          yield* this._readString();
          buf = this._retBuffer.read();
          ret.push([CborTypes.RET_UTF, buf ? buf.toString('utf8') : '']);
          break;
        case CborTypes.TYPE_ARRAY >> 5:
          ret.push([CborTypes.RET_ARR_HEADER, this._mFieldValue]);
          yield* this._readArray(sync);
          break;
        case CborTypes.TYPE_MAP >> 5:
          ret.push([CborTypes.RET_MAP_HEADER, this._mFieldValue]);
          yield* this._readMap(sync);
          break;
        case CborTypes.TYPE_TAG >> 5:
          let tag = this._mFieldValue;
          switch(tag) {
            case CborTypes.TAG_POSBIGINT:
            case CborTypes.TAG_NEGBIGINT:
              ret.push([CborTypes.RET_BIGINT, (yield* this._readBigInt()).toPrecision()]);
          // in order to get plain string instead of scientific rep,
          // in the future should switch to 'toString()'
              break;
            case CborTypes.TAG_DECIMAL:
            case CborTypes.TAG_BIGFLOAT:
              ret.push([CborTypes.RET_BIGDEC, (yield* this._readBigDecimal()).toString()]);
              break;
        // case CborTypes.TAG_DATETIME:
        // case CborTypes.TAG_TIMESTAMP:
            default:
              isUnknownTag = true;
              ret.push([CborTypes.RET_TAG, tag]);
              this._consumeField();
          }
          break;
        case CborTypes.TYPE_SIMPLE >> 5:
          switch(type & CborTypes.MINOR_TYPE_MASK) {
            case CborTypes.TYPE_FALSE & CborTypes.MINOR_TYPE_MASK:
              this._consumeField();
              ret.push([CborTypes.RET_BOOL, false]);
              break;
            case CborTypes.TYPE_TRUE & CborTypes.MINOR_TYPE_MASK:
              this._consumeField();
              ret.push([CborTypes.RET_BOOL, true]);
              break;
            case CborTypes.TYPE_NULL & CborTypes.MINOR_TYPE_MASK:
              this._consumeField();
              ret.push([CborTypes.RET_NULL, null]);
              break;
            case CborTypes.TYPE_UNDEFINED & CborTypes.MINOR_TYPE_MASK:
              this._consumeField();
              ret.push([CborTypes.RET_UNDEFINED, undefined]);
              break;
            case CborTypes.TYPE_FLOAT_16 & CborTypes.MINOR_TYPE_MASK:
            case CborTypes.TYPE_FLOAT_32 & CborTypes.MINOR_TYPE_MASK:
            case CborTypes.TYPE_FLOAT_64 & CborTypes.MINOR_TYPE_MASK:
              ret.push([CborTypes.RET_FLOAT, yield* this._readFloat()]);
              break;
            case CborTypes.TYPE_BREAK & CborTypes.MINOR_TYPE_MASK:
              throw new DaxClientError('end of stream', DaxErrorCode.EndOfStream);
            default:
              throw new DaxClientError(`Unsupported simple type: ${type}`, DaxErrorCode.Decoder);
          }
          break;
        default:
          throw new DaxClientError('unknown major type', DaxErrorCode.Decoder);
      }
    } while(isUnknownTag);
  }

  * _readType() {
    let type = this._mFieldType;
    if(type >= 0) {
      return type;
    }
    type = (yield 1)[0];
    const majorType = type >> 5;
    const ai = type & CborTypes.MINOR_TYPE_MASK;
    let val;
    switch(ai) {
      case CborTypes.SIZE_8:
        val = (yield 1)[0];
        val = CborDecoder._isReadAsBuf(majorType) ? Buffer.from([val]) : val;
        break;
      case CborTypes.SIZE_16:
      case CborTypes.SIZE_32:
      case CborTypes.SIZE_64:
        const numbytes = 1 << (ai - 24);
        const buf = yield numbytes;
        val = CborDecoder._isReadAsBuf(majorType) ? buf : CborDecoder._parseCBORint(ai, buf);
        break;
      case CborTypes.SIZE_ILLEGAL_1:
      case CborTypes.SIZE_ILLEGAL_2:
      case CborTypes.SIZE_ILLEGAL_3:
        throw new DaxClientError('illegal field size', DaxErrorCode.Decoder);
      case CborTypes.SIZE_STREAM:
        val = -1; // -1 for fieldvalue
        break;
      default:
        val = CborDecoder._isReadAsBuf(majorType) ? Buffer.from([ai]) : ai;
    }
    this._mFieldType = type;
    this._mFieldValue = val;
    return type;
  }

  static _isReadAsBuf(majorType) {
    switch(majorType) {
      case CborTypes.TYPE_SIMPLE >> 5:
      case CborTypes.TYPE_POSINT >> 5:
      case CborTypes.TYPE_NEGINT >> 5:
        return true;
      default:
        return false;
    }
  }

  * _parse(sync) {
    yield* this._readObject(sync);
  }
}

// these two objs are only used for Sync method above(decodeAll/PartialSync),
// in order to mitigate obj allocation. And it won't be used by more than one method/request at same time,
// since node guarentee that sync code will run until end before hand over.
const sharedSyncMethodBuf = new StreamBuffer();
const sharedSyncMethodDecoder = new CborDecoder();

module.exports = CborDecoder;
