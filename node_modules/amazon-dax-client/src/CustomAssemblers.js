/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not
 * use this file except in compliance with the License. A copy of the License
 * is located at
 *
 *    http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
'use strict';

const Assembler = require('../src/Assembler');
const Util = require('../src/Util');
const DaxClientError = require('../src/DaxClientError');
const DaxErrorCode = require('../src/DaxErrorCode');
const CborTypes = require('./CborTypes');

exports.Custom_defineKeySchema_N742646399_1_Assembler = class Custom_defineKeySchema_N742646399_1_Assembler extends Assembler.Assembler {
  * _decode_defineKeySchema_N742646399_1_Result() {
    let schema = [];
    let mapHeader = yield;
    for(let i = 0; i < mapHeader[1]; ++i) {
      let an = yield* this._getString();
      let at = yield* this._getString();
      // this might be improved by only store it as an array
      schema.push({AttributeName: an, AttributeType: at});
    }
    return schema;
  }
};

exports.Custom_defineAttributeList_670678385_1_Assembler = class Custom_defineAttributeList_670678385_1_Assembler extends Assembler.Assembler {
  * _decode_defineAttributeList_670678385_1_Result() {
    let result = yield* Assembler.assembleObjectf();
    return result;
  }
};

exports.Custom_defineAttributeListId_N1230579644_1_Assembler = class Custom_defineAttributeListId_N1230579644_1_Assembler extends Assembler.Assembler {
  * _decode_defineAttributeListId_N1230579644_1_Result() {
    let result = yield* Assembler.assembleObjectf();
    return result;
  }
};

exports.Custom_endpoints_455855874_1_Assembler = class Custom_endpoints_455855874_1_Assembler extends Assembler.Assembler {
  * _decode_endpoints_455855874_1_Result() {
    let result = yield* Assembler.assembleObjectf();
    let eps = [];
    for(let ep of result) {
      if(!(ep[2] instanceof Buffer) && ep[2].length !== 4) {
        throw new DaxClientError('unexpected Endpoint IP address', DaxErrorCode.MalformedResult);
      }
      ep[2] = ep[2].readUInt8(0) + '.' + ep[2].readUInt8(1) + '.' + ep[2].readUInt8(2) + '.' + ep[2].readUInt8(3);
      eps.push(Util.serviceEndpointFrom(ep[0], ep[1], ep[2], ep[3], ep[4], ep[5], ep[6]));
    }
    return eps;
  }
};

exports.Custom_batchGetItem_N697851100_1_Assembler = class Custom_batchGetItem_N697851100_1_Assembler extends Assembler.Assembler {
  * _decode_batchGetItem_N697851100_1_Result() {
    let arrHeader = yield* this._getArrayHeader();
    if(arrHeader !== 2) {
      throw new DaxClientError('BatchGetResponse needs to have two elements, instead had: ' + arrHeader, DaxErrorCode.MalformedResult);
    }
    let mapHeader = yield* this._getMapHeader();
    let response = {};

    let keysPerTable = this._request._keysPerTable;

    let deanonymizeJobs = [];

    for(let i = 0; i < mapHeader; ++i) {
      let tableName = yield* this._getString();
      let numItems = yield* this._getArrayHeader();
      let tableItems = [];
      let projOrdinals = this._request._tableProjOrdinals[tableName];
      response[tableName] = tableItems;

      if(projOrdinals.length > 0) {
        while(numItems > 0) {
          let data = yield;
          let item;
          let retType = data[0];
          switch(retType) {
            case CborTypes.RET_MAP_HEADER:
              item = yield* Assembler.Assembler._decodeProjection(data[1], projOrdinals);
              response[tableName].push(item);
              break;
            case CborTypes.RET_BUF:
              item = this._decodeStreamItem(data[1]); // sync method since data is already here
              response[tableName].push(item);
              deanonymizeJobs.push(this._request._attrListCache.get(item._attrListId).then((attrNames) => {
                Util.deanonymizeAttributeValues(item, attrNames);
                return Promise.resolve();
              }));
              break;
            case CborTypes.RET_NULL:
              break;
            default:
              throw new DaxClientError(`invalid type of ${item}`, DaxErrorCode.MalformedResult);
          }
          numItems--;
        }
      } else {
        let tableKeys = keysPerTable[tableName];
        while(numItems > 0) {
          let key = yield* Assembler.Assembler._decodeKeyBytes(tableKeys);
          let item = yield* this._decodeStreamItemAsync();
          response[tableName].push(Object.assign(item, key));
          deanonymizeJobs.push(this._request._attrListCache.get(item._attrListId).then((attrNames) => {
            Util.deanonymizeAttributeValues(item, attrNames);
            return Promise.resolve();
          }));
          numItems -= 2;
        }
      }
    }

    // read in unprocessed keys
    let unprocessedKeysMapLen = yield* this._getMapHeader();
    let unprocessedKeys = {};
    while(unprocessedKeysMapLen-- > 0) {
      let tableName = yield* this._getString();
      let keyCount = yield* this._getArrayHeader();
      if(keyCount === 0) {
        continue;
      }

      unprocessedKeys[tableName] = {Keys: []};
      let tableKeys = keysPerTable[tableName];
      while(keyCount-- > 0) {
        let item = yield* Assembler.Assembler._decodeKeyBytes(tableKeys);
        unprocessedKeys[tableName].Keys.push(item);
      }
      if(this._request.RequestItems[tableName].ProjectionExpression) {
        unprocessedKeys[tableName].ProjectionExpression = this._request[tableName].RequestItems.ProjectionExpression;
      }
      if(this._request.RequestItems[tableName].ConsistentRead) {
        unprocessedKeys[tableName].ConsistentRead = this._request[tableName].RequestItems.ConsistentRead;
      }
      if(this._request.RequestItems[tableName].AttributesToGet) {
        unprocessedKeys[tableName].AttributesToGet = this._request[tableName].RequestItems.AttributesToGet;
      }
      if(this._request.RequestItems[tableName].ExpressionAttributeNames) {
        unprocessedKeys[tableName].ExpressionAttributeNames = this._request[tableName].RequestItems.ExpressionAttributeNames;
      }
    }

    let consumedCapacityArrayLen = yield* this._getArrayHeader();
    let consumedCapacity = [];
    while(consumedCapacityArrayLen-- > 0) {
      consumedCapacity.push(yield* this._decodeConsumedCapacity());
    }

    let result = {};

    if(this._request.ReturnConsumedCapacity && this._request.ReturnConsumedCapacity !== 'NONE') {
      consumedCapacity = verifyBatchConsumedCapacity(consumedCapacity, Object.keys(keysPerTable));
      result.ConsumedCapacity = consumedCapacity;
    }

    return Promise.all(deanonymizeJobs).then(() => {
      return Object.assign(result, {Responses: response, UnprocessedKeys: unprocessedKeys});
    });
  }
};

exports.Custom_batchWriteItem_116217951_1_Assembler = class Custom_batchWriteItem_116217951_1_Assembler extends Assembler.Assembler {
  * _decode_batchWriteItem_116217951_1_Result() {
    let keysPerTable = this._request._keysPerTable;
    let deanonymizeJobs = [];
    let unprocessedItemsByTable = {};
    let numTables = yield* this._getMapHeader();

    // Gather unprocessed items
    for(let i = 0; i < numTables; ++i) {
      let tableName = yield* this._getString();
      unprocessedItemsByTable[tableName] = [];
      let tableKeys = keysPerTable[tableName];
      let numItems = yield* this._getArrayHeader() / 2;

      while(numItems-- > 0) {
        let key = yield* Assembler.Assembler._decodeKeyBytes(tableKeys);
        let item;
        let data = yield;
        if(data[0] === CborTypes.RET_NULL) {
          // DeleteRequest
          unprocessedItemsByTable[tableName].push({DeleteRequest: {Key: key}});
        } else {
          // PutRequest
          item = this._decodeStreamItem(data[1]);
          deanonymizeJobs.push(this._request._attrListCache.get(item._attrListId).then((attrNames) => {
            unprocessedItemsByTable[tableName].push({PutRequest: {Item: Object.assign(key, Util.deanonymizeAttributeValues(item, attrNames))}});
            return Promise.resolve();
          }));
        }
      }
    }

    let consumedCapacityArrayLen = yield* this._getArrayHeader();
    let consumedCapacities = [];
    if(consumedCapacityArrayLen > 0) {
      while(consumedCapacityArrayLen-- > 0) {
        consumedCapacities.push(yield* this._decodeConsumedCapacity());
      }
    }

    let itemCollectionMetricsMapLength = yield* this._getMapHeader();
    let batchWriteItemCollectionMetrics = {};
    for(let i = 0; i < itemCollectionMetricsMapLength; ++i) {
      let tableName = yield* this._getString();
      let tableKeys = keysPerTable[tableName];
      let numberOfMetrics = yield* this._getArrayHeader();
      let metricsList = [];
      for(let j = 0; j < numberOfMetrics; ++j) {
        metricsList.push(yield* this._decodeItemCollectionMetrics(tableKeys));
      }
      batchWriteItemCollectionMetrics[tableName] = metricsList;
    }

    let result = {};
    if(Object.keys(batchWriteItemCollectionMetrics).length > 0) {
      result = {ItemCollectionMetrics: batchWriteItemCollectionMetrics};
    }
    if(this._request.ReturnConsumedCapacity && this._request.ReturnConsumedCapacity !== 'NONE') {
      let consumedCapacity = verifyBatchConsumedCapacity(consumedCapacities, Object.keys(keysPerTable));
      result.ConsumedCapacity = consumedCapacity;
    }

    return Promise.all(deanonymizeJobs).then(() => {
      return Object.assign(result, {UnprocessedItems: unprocessedItemsByTable});
    });
  }
};

function verifyBatchConsumedCapacity(consumedCapacityByTable, tables) {
  let tablesWithConsumedCapacity = new Set();
  if(consumedCapacityByTable) {
    for(let capacity of consumedCapacityByTable) {
      if(capacity) {
        tablesWithConsumedCapacity.add(capacity.TableName);
      }
    }
  }
  for(let table of tables) {
    if(!tablesWithConsumedCapacity.has(table)) {
      let consumedCapacity = {};
      consumedCapacity.TableName = table;
      consumedCapacity.CapacityUnits = 0;
      consumedCapacityByTable.push(consumedCapacity);
    }
  }
  return consumedCapacityByTable;
}
