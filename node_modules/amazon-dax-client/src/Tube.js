/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not
 * use this file except in compliance with the License. A copy of the License
 * is located at
 *
 *    http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
'use strict';

const CborEncoder = require('./CborEncoder');
const DaxClientError = require('./DaxClientError');
const DaxErrorCode = require('./DaxErrorCode');
const net = require('net');
const SessionVersion = require('./SessionVersion');
const SigV4Gen = require('./SigV4Gen');
const StreamBuffer = require('../src/ByteStreamBuffer');

const MAGIC_STRING = 'J7yne5G';
const USER_AGENT_STRING = 'UserAgent';
const USER_AGENT = 'DaxJSClient-1.0';
const WINDOW_SCALAR = 0.1;
const DAX_ADDR = 'https://dax.amazonaws.com';
const BUFFER_ZERO = Buffer.from([0]);
const DEFAULT_FLUSH_SIZE = 4096;

exports.USER_AGENT = USER_AGENT;

class ClientTube {
  constructor(socket, version, credProvider, region) {
    socket.setKeepAlive(true);
    socket.setNoDelay(true);
    this.socket = socket;
    this._authExp = 0;
    this._nextTube = null;
    this._authTTLMillis = 5 * 60 * 1000;
    this._poolWindow = (this._authTTLMillis / 2);
    this._tubeWindow = (this._authTTLMillis * WINDOW_SCALAR);
    this._region = region;
    this._credProvider = credProvider;
    this._sessionVersion = version;
    this.buf = new StreamBuffer();
    this.cbor = new CborEncoder();
    this._init(version.session);
  }

  _init(session) {
    this.socket.write(this.cbor.encodeString(MAGIC_STRING));
    this.socket.write(BUFFER_ZERO);

    if(!session) {
      this.socket.write(this.cbor.encodeNull());
    } else {
      this.socket.write(this.cbor.encodeBinary(session));
    }

    this.socket.write(this.cbor.encodeMapHeader(1));

    this.socket.write(this.cbor.encodeString(USER_AGENT_STRING));
    this.socket.write(this.cbor.encodeString(USER_AGENT)); // FIXME

    this.socket.write(BUFFER_ZERO);
  }

  close() {
    this.socket.end();
  }

  write(data) {
    this.buf.write(data);
    if(this.buf.length >= DEFAULT_FLUSH_SIZE) {
      this.socket.write(this.buf.read());
    }
  }

  flush(data) {
    if(this.buf.length > 0) {
      this.socket.write(this.buf.read());
    }
  }

  reauth() {
    let currTime = Date.now();
    if(this._authExp - currTime <= this._tubeWindow
        || currTime - this._lastPoolAuth >= this._poolWindow) {
      return this._credProvider.resolvePromise().then((creds) => {
        this._checkAndUpdateAccessKeyId(creds.accessKeyId);
        this._lastPoolAuth = currTime;
        this._authExp = currTime + this._authTTLMillis;

        this._authHandler(creds);

        // return the containing tube for further use
        return this;
      });
    } else {
      return Promise.resolve(this);
    }
  }

  invalidateAuth() {
    this._authExp = 0;
  }

  _authHandler(creds) {
    // Make sure the same credentials are used to sign and authorize.
    let sigHead = SigV4Gen.generateSigAndStringToSign(creds, DAX_ADDR, this._region, '');

    this.write(this.cbor.encodeInt(1));
    this.write(this.cbor.encodeInt(1489122155));
    this.write(this.cbor.encodeString(creds.accessKeyId));

    this.write(this.cbor.encodeString(sigHead.signature));

    this.write(this.cbor.encodeBinary(Buffer.from(sigHead.stringToSign)));

    this.write(sigHead.sessionToken === null ? this.cbor.encodeNull() : this.cbor.encodeString(sigHead.sessionToken));

    this.write(USER_AGENT === null ? this.cbor.encodeNull() : this.cbor.encodeString(USER_AGENT));
  }

  _checkAndUpdateAccessKeyId(other) {
    if(!other) {
      throw new DaxClientError('AWSCredentialsProvider provided null AWSAccessKeyId', DaxErrorCode.Authentication, false);
    }
    let equality = (other === this._accessKeyId);
    if(!equality) {
      this._accessKeyId = other;
    }
    return equality;
  }
}

class SocketTubePool {
  constructor(hostname, port, credProvider, region, tube) {
    this._hostname = hostname;
    this._port = port;
    this._headTube = tube ? tube : null;

    this._region = region;
    this._credProvider = credProvider;
    this._sessionVersion = SessionVersion.create();

    this._connection = 0;
    this._total = 0;
    if(tube) {
      this._connection = 1;
    }
  }

  alloc() {
    let tube = this._headTube;
    this._total++;
    if(tube) {
      this._headTube = tube._nextTube;
      if(this._lastActiveTube === tube) {
        this._lastActiveTube = this._headTube;
      }
      tube._nextTube = null;
      return Promise.resolve(tube);
    } else {
      ++this._connection;
      return this._alloc();
    }
  }

  _alloc() {
    // seperate this out since we can better unit test with mocking this func out.
    return new Promise((resolve, reject) => {
      let socket = net.createConnection(this._port, this._hostname);
      socket.on('connect', () => {
        let newTube = new ClientTube(socket, this._sessionVersion, this._credProvider, this._region);
        return resolve(newTube);
      }).on('error', (err) => {
        return reject(err);
      });
    });
  }

  recycle(tube) {
    if(!tube) {
      return;
    }
    if(tube._sessionVersion === this._sessionVersion) {
      tube._nextTube = this._headTube;
      this._headTube = tube;
    } else {
      tube.close();
    }
  }

  reset(tube) {
    if(!tube) {
      return;
    }
    tube.close();
    if(tube._sessionVersion !== this._sessionVersion) {
      return;
    }
    this._versionBump();
    tube = this._headTube;
    this._headTube = this._lastActiveTube = null;
    this._closeAll(tube);
  }

  close() {
    this._versionBump();
    let tube = this._headTube;
    this._headTube = this._lastActiveTube = null;
    this._closeAll(tube);
  }

  _closeAll(tube) {
    let reapCount = 0;
    let next;
    while(tube) {
      reapCount++;
      tube.close();
      next = tube._nextTube;
      tube._nextTube = null;
      tube = next;
    }
    return reapCount;
  }

  _versionBump() {
    this._sessionVersion = SessionVersion.create();
  }

  reapIdleTubes() {
    let lastActiveTube = this._lastActiveTube;
    let toReap = null;
    if(lastActiveTube) {
      toReap = lastActiveTube._nextTube;
      lastActiveTube._nextTube = null;
    }
    this._lastActiveTube = this._headTube;
    this._closeAll(toReap);
    this._connection = 0;
  }
}

module.exports = {
  ClientTube: ClientTube,
  SocketTubePool, SocketTubePool,
};
