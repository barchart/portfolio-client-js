/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not
 * use this file except in compliance with the License. A copy of the License
 * is located at
 *
 *    http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
'use strict';

const DEFAULT_INIT_SIZE = 1024;
class ByteStreamBuffer {
  constructor(size) {
    this._pos = 0;
    this._end = 0;
    this.buf = Buffer.alloc(size || DEFAULT_INIT_SIZE);
  }

  write(data, length) {
    // length writing only support for buffer target
    if(!length && length !== 0) {
      length = data.length;
    }

    if(typeof data === 'string') {
      this._ensureSpaces(length * 4); // each utf8 character will be converted at most 4 bytes
      let writeBytes = this.buf.write(data, this._end, 'utf8');
      this._end += writeBytes;
    } else if(Buffer.isBuffer(data)) {
      this._ensureSpaces(length);
      data.copy(this.buf, this._end, 0, length);
      this._end += length;
    } else {
      throw new Error('buf.write() only support Buffer/string');
    }
  }

  _ensureSpaces(size) {
    if(size + this._end > this.buf.length) {
      let needSize = size + this._end - this._pos;

      let enlargeSize = this.buf.length;
      while(enlargeSize < needSize) {
        enlargeSize <<= 1;
      }

      let buf = Buffer.alloc(enlargeSize);
      this.buf.copy(buf, 0, this._pos);
      this.buf = buf;
      this._end -= this._pos;
      this._pos = 0;
    }
  }

  read(num) {
    if(num < 0) {
      return null;
    }

    if(this.length === 0) {
      return null;
    }

    if(!num) {
      num = this.length;
    }

    if(!this.buf || (this._end - this._pos) < num) {
      return null;
    }

    let readBuf = this.buf.slice(this._pos, this._pos + num);
    this._pos += num;
    return readBuf;
  }

  get length() {
    return this._end - this._pos;
  }
}

module.exports = ByteStreamBuffer;
