/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not
 * use this file except in compliance with the License. A copy of the License
 * is located at
 *
 *    http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
'use strict';
const TransformStream = require('stream').Transform;
const CborDecoder = require('./CborDecoder');
const ItemBuilder = require('./ItemBuilder');
const CborTypes = require('./CborTypes');
const DaxCborTypes = require('./DaxCborTypes');
const LexDecimal = require('./LexDecimal');
const DaxClientError = require('./DaxClientError');
const DaxServiceError = require('./DaxServiceError');
const DaxErrorCode = require('./DaxErrorCode');

const CborToDDBMaping = {[CborTypes.RET_INT]: 'N',
  [CborTypes.RET_UTF]: 'S',
  [CborTypes.RET_BUF]: 'B',
  [CborTypes.RET_BIGINT]: 'N',
  [CborTypes.RET_BIGDEC]: 'N',
  [CborTypes.RET_FLOAT]: 'N',
  [CborTypes.RET_BOOL]: 'BOOL',
  [CborTypes.RET_NULL]: 'NULL',
  [CborTypes.RET_MAP_HEADER]: 'M',
  [CborTypes.RET_ARR_HEADER]: 'L',
  [DaxCborTypes.TAG_DDB_STRING_SET]: 'SS',
  [DaxCborTypes.TAG_DDB_NUMBER_SET]: 'NS',
  [DaxCborTypes.TAG_DDB_BINARY_SET]: 'BS'};

const STREAMBREAK = Symbol('retStreamBreak');

let convertArrToObjList = exports.convertArrToObjList = function(arr, isAttributeValue) {
  // if isAttributeValue is true, then return list is AV list.
  let assembler = null;
  let i = 0;
  let len = arr.length;
  let avs = [];
  while(i < len) {
    if(!assembler) {
      assembler = assembleObjectf(isAttributeValue);
      assembler.next();
    }
    let ret = assembler.next(arr[i++]);
    if(ret.done) {
      avs.push(ret.value);
      assembler = null;
    }
  }
  return avs;
};

let convertArrToSingleObject = exports.convertArrToSingleObject = function(arr, isAttributeValue) {
    // if isAttributeValue is true, then return list is AV list.
  let assembler = null;
  let i = 0;
  let len = arr.length;
  while(i < len) {
    if(!assembler) {
      assembler = assembleObjectf(isAttributeValue);
      assembler.next();
    }
    let ret = assembler.next(arr[i++]);
    if(ret.done) {
      return {
        object: ret.value,
        lastIndex: i,
      };
    }
  }
};


let assembleObjectf = exports.assembleObjectf = function* (isAttributeValue) {
  let assembled;

  let isUnknownTag;
  do {
    isUnknownTag = false;
    let val = yield;
    let type = val[0];
    let data = val[1];
    let list;
    switch(type) {
      case CborTypes.RET_ARR_HEADER:
        list = yield* _assembleArray(data, isAttributeValue);
        assembled = (isAttributeValue ? {'L': list} : list);
        break;
      case CborTypes.RET_MAP_HEADER:
        let map = yield* _assembleMap(data, isAttributeValue);
        assembled = (isAttributeValue ? {'M': map} : map);
        break;
      case CborTypes.RET_TAG:
        switch(data) {
          case DaxCborTypes.TAG_DDB_STRING_SET:
          case DaxCborTypes.TAG_DDB_NUMBER_SET:
          case DaxCborTypes.TAG_DDB_BINARY_SET:
            list = yield* _assembleArray((yield)[1], false);
            assembled = (isAttributeValue ? {[CborToDDBMaping[data]]: list} : list);
            break;
          default:
            isUnknownTag = true;
        // just skip unknown tag
        }
        break;
      case CborTypes.RET_STREAM_BREAK:
        return STREAMBREAK;
      default:
        // For attribute values, NULL value should be true, not null
        let adjData = type === CborTypes.RET_NULL ? true : data;
        assembled = (isAttributeValue ? {[CborToDDBMaping[type]]: adjData} : data);
    }
  } while(isUnknownTag);
  return assembled;
};

function* _assembleArray(len, isAttributeValue) {
  let arr = [];
  for(let i = 0; i !== len; ++i) {
    // use !== since len could be -1, and will check in following
    let obj = yield* assembleObjectf(isAttributeValue);
    if(obj === STREAMBREAK) {
      if(len === -1) {
        return arr;
      } else {
        throw new DaxClientError('unexpected Stream Break', DaxErrorCode.MalformedResult);
      }
    }
    arr.push(obj);
  }
  return arr;
}

function* _assembleMap(len, isAttributeValue) {
  let obj = {};
  for(let i = 0; i !== len; ++i) { // include streaming
    let key = yield* assembleObjectf();
    if(key === STREAMBREAK) {
      if(len === -1) {
        return obj;
      } else {
        throw new DaxClientError('unexpected Stream Break', DaxErrorCode.MalformedResult);
      }
    }
    let value = yield* assembleObjectf(isAttributeValue);
    obj[key] = value;
  }
  return obj;
}

exports.Assembler = class Assembler extends TransformStream {
  constructor(request, keySchema) {
    super({objectMode: true});
    this._request = request;
    this._keySchema = keySchema;

    this._assembler = this.assemblef();
    this._assembler.next();
    this._finish = false;
  }

  _transform(chunk, encoding, callback) {
    let ret;
    try {
      ret = this._assembler.next(chunk);
    } catch(err) {
      return callback(err);
    }

    if(ret.done) {
      this.push(ret.value);
      this._restart();
    }

    callback();
  }

  _restart() {
    this._assembler = this.assemblef();
    this._assembler.next();
  }

  * _handleError() {
    let codeSeq = yield* assembleObjectf();

    if(!codeSeq) {
      throw new DaxClientError('Response cannot be null', DaxErrorCode.MalformedResult);
    }

    if(codeSeq.constructor !== Array) {
      throw new DaxClientError('Response header must be an array', DaxErrorCode.MalformedResult);
    }

    if(codeSeq.length === 0) {
      return {done: true};
    }

    for(let i = 0; i < codeSeq.length; i++) {
      if(!codeSeq[i] || Number.isNaN(codeSeq[i]) || String(Number.parseInt(codeSeq[i])) !== codeSeq[i]) {
        throw new DaxClientError('Error codes must be in integer range', DaxErrorCode.MalformedResult);
      }
      codeSeq[i] = Number.parseInt(codeSeq[i]);
    }

    let errMsg = yield* assembleObjectf();
    if(!errMsg || errMsg.constructor !== String) {
      throw new DaxClientError('Expected non-null string', DaxErrorCode.MalformedResult);
    }

    let requestId = null;
    let errorCode = null;
    let statusCode = -1;
    let retryable;

    let codes = yield* assembleObjectf();

    if(codes !== null) {
      if(codes.length != 3) {
        throw new DaxClientError('Expected 3 elements in the exception info', DaxErrorCode.MalformedResult);
      }
      requestId = codes[0];
      errorCode = codes[1];
      statusCode = codes[2];
    }
    throw new DaxServiceError(errMsg, errorCode, retryable, requestId, statusCode, codeSeq);
  }

  _reinsertKey(item) {
    // Handle GetItem, UpdateItem, DeleteItem
    if(this._request.Key && !this._request._projectionOrdinals) {
      Object.assign(item, this._request.Key); // The key attributes are only added if it's NOT a projection
      return;
    }

    // Handle PutItem
    if(this._request.Item) {
      for(let keyAttr of this._keySchema) {
        if(!(keyAttr.AttributeName in this._request.Item)) {
          throw new DaxClientError(`Request Item is missing key attribute "${keyAttr.AttributeName}".`,
            DaxErrorCode.MalformedResult);
        }

        item[keyAttr.AttributeName] = this._request.Item[keyAttr.AttributeName];
      }
    }
    return;
  }

  * _decodeItems() {
    let data = yield;
    let items;
    let retType = data[0];
    switch(retType) {
      case CborTypes.RET_ARR_HEADER:
        let count = data[1];
        items = [];
        for(let i = 0; i !== count; i++) {
          let paramId = yield; // could be Stream Break
          if(paramId[0] === CborTypes.RET_STREAM_BREAK) {
            break;
          }
          items.push(yield* this._decodeItemInternal(paramId));
        }

        break;

      case CborTypes.RET_NULL:
        items = null;
        break;

      default:
        throw new DaxClientError(`Items field must be an array, got ${retType}.`, DaxErrorCode.MalformedResult);
    }

    return items;
  }

  * _decodeAttributes() {
    let isProjection = this._request.ReturnValues &&
      (this._request.ReturnValues === 'UPDATED_NEW' ||
        this._request.ReturnValues === 'UPDATED_OLD');

    let item = this._decodeStreamItem(yield* this._getBinary(), isProjection);
    if(item && !isProjection) {
      this._reinsertKey(item);
    }

    return item;
  }

  * _decodeItem() {
    let data = yield;
    return yield* this._decodeItemInternal(data);
  }

  * _decodeItemInternal(data) {
    let item;
    let retType = data[0];
    switch(retType) {
      case CborTypes.RET_MAP_HEADER:
        item = yield* this._decodeProjection(data[1]);
        break;
      case CborTypes.RET_BUF:
        item = this._decodeStreamItem(data[1]); // sync method since data is already here
        break;
      case CborTypes.RET_ARR_HEADER:
        item = yield* this._decodeScanResult(data[1]);
        break;
      case CborTypes.RET_NULL:
        item = null;
        break;
      default:
        throw new DaxClientError(`invalid type of ${item}`, DaxErrorCode.MalformedResult);
    }

    if(item) {
      this._reinsertKey(item);
    }

    return item;
  }

  static* _decodeProjection(maplength, projectionOrdinals) {
    if(!projectionOrdinals) {
      throw new DaxClientError('Projection Ordinals must not be null on projected value', DaxErrorCode.MalformedResult);
    }

    let builder = new ItemBuilder();

    for(let i = 0; i !== maplength; i++) { // include streaming
      let data = yield;
      switch(data[0]) {
        case CborTypes.RET_INT:
          yield* Assembler._decodeProjectionElement(parseInt(data[1]), builder, projectionOrdinals);
          break;
        case CborTypes.RET_STREAM_BREAK:
          return builder.toItem();
        default:
          throw new DaxClientError('Invalid type, should be either Int or StreamBreak', DaxErrorCode.MalformedResult);
      }
    }

    return builder.toItem();
  }

  static* _decodeProjectionElement(ord, builder, projectionOrdinals) {
    let path = projectionOrdinals[ord];
    if(!path) {
      throw new DaxClientError('Unknown projection ordinal: ' + ord, DaxErrorCode.MalformedResult);
    }
    let av = yield* assembleObjectf(true);
    builder.with(path, av);
  }

  * _decodeProjection(maplength) {
    return (yield* Assembler._decodeProjection(maplength, this._request._projectionOrdinals));
  }

  _decodeStreamItem(data, isProjection) {
    let arr = CborDecoder.decodeAllSync(data);
    let item = {};
    if(arr[0][0] === CborTypes.RET_NULL) {
      return null;
    }

    item._attrListId = arr[0][1];
    arr.shift();

    if(!isProjection) {
      // the whole item is present, so decode it normally
      item._anonymousAttributeValues = convertArrToObjList(arr, true);
    } else {
      // only a partial item is present that will be reconstructed during
      // de-anonymization, when the attrList is available
      // so for now, store the attributes in a map indexed by the ordinal
      if(arr[0][0] !== CborTypes.RET_MAP_HEADER) {
        throw new DaxClientError('Expected map header, got ' + arr[0][0], DaxErrorCode.MalformedResult);
      }

      let attrVals = [];

          // get the number of projection items
      let projLen = arr[0][1];
      arr.shift();

      for(let i = 0; i !== projLen; i++) { // !== to allow for unbounded maps
        if(arr[0][0] === CborTypes.RET_STREAM_BREAK) {
          break;
        }

        if(arr[0][0] !== CborTypes.RET_INT) {
          throw new DaxClientError('Expected integer, got ' + arr[0][0], DaxErrorCode.MalformedResult);
        }

        let pathOrdinal = parseInt(arr[0][1]);
        arr.shift();

        let result = convertArrToSingleObject(arr, true);

        attrVals[pathOrdinal] = result.object;
        arr = arr.slice(result.lastIndex, arr.length);
      }

      item._anonymousAttributeValues = attrVals;
    }

    return item;
  }

  * _decodeScanResult(length) {
    if(length !== 2) {
      throw new DaxClientError(`Invalid scan item length ${length}`, DaxErrorCode.MalformedResult);
    }

    if(!this._keySchema) {
      throw new DaxClientError(`Key schema is required to decode items. (Got ${this._keySchema})`, DaxErrorCode.MalformedResult);
    }

    let item = {};
    let key = yield* this._decodeKeyBytes();
    item = Object.assign(item, key);

    let value = yield* this._decodeScanValue();
    item = Object.assign(item, value);

    return item;
  }

  static* _decodeKeyBytes(keySchema) {
    let data = yield;
    if(data[0] !== CborTypes.RET_BUF) {
      throw new DaxClientError(`Key must be of type ${CborTypes.RET_BUF}, got ${data[0]}`, DaxErrorCode.MalformedResult);
    }

    let keyBytes = data[1];

    let key = {};
    let hashAttr = keySchema[0];
    if(keySchema.length == 1) {
      switch(hashAttr.AttributeType) {
        case 'S':
          key[hashAttr.AttributeName] = {'S': keyBytes.toString('utf-8')};
          break;
        case 'N':
          let allData = CborDecoder.decodeAllSync(keyBytes);
          if(allData.length !== 1) {
            throw new DaxClientError(`Decoded key is wrong size; expected 1, got ${allData.length}`, DaxErrorCode.MalformedResult);
          }

          let data = allData[0];
          if(data[0] !== CborTypes.RET_INT) {
            throw new DaxClientError(`Invalid type for N: got ${data[0]}, expected ${CborTypes.RET_INT}`, DaxErrorCode.MalformedResult);
          }

          key[hashAttr.AttributeName] = {'N': data[1]};
          break;
        case 'B':
          key[hashAttr.AttributeName] = {'B': keyBytes};
          break;
        default:
          throw new DaxClientError(`Key must be S, B or N, instead key is: ${hashAttr}`, DaxErrorCode.MalformedResult);
      }
    } else if(keySchema.length == 2) {
      let ref = {};
      switch(hashAttr.AttributeType) {
        case 'S': {
          let allData = CborDecoder.decodePartialSync(keyBytes, ref, 1);
          if(allData.length !== 1) {
            throw new DaxClientError(`Decoded hash is wrong size; expected 1, got ${allData.length}`, DaxErrorCode.MalformedResult);
          }

          let data = allData[0];
          if(data[0] !== CborTypes.RET_UTF) {
            throw new DaxClientError(`Invalid type for hash S: got ${data[0]}, expected ${CborTypes.RET_UTF}`, DaxErrorCode.MalformedResult);
          }

          key[hashAttr.AttributeName] = {'S': data[1]};
          break;
        }
        case 'N': {
          let allData = CborDecoder.decodePartialSync(keyBytes, ref, 1);
          if(allData.length !== 1) {
            throw new DaxClientError(`Decoded hash is wrong size; expected 1, got ${allData.length}`, DaxErrorCode.MalformedResult);
          }

          let data = allData[0];
          if(data[0] !== CborTypes.RET_INT) {
            throw new DaxClientError(`Invalid type for hash N: got ${data[0]}, expected ${CborTypes.RET_INT}`, DaxErrorCode.MalformedResult);
          }

          key[hashAttr.AttributeName] = {'N': data[1]};
          break;
        }
        case 'B': {
          let allData = CborDecoder.decodePartialSync(keyBytes, ref, 1);
          if(allData.length !== 1) {
            throw new DaxClientError(`Decoded hash is wrong size; expected 1, got ${allData.length}`, DaxErrorCode.MalformedResult);
          }

          let data = allData[0];
          if(data[0] !== CborTypes.RET_BUF) {
            throw new DaxClientError(`Invalid type for hash B: got ${data[0]}, expected ${CborTypes.RET_BUF}`, DaxErrorCode.MalformedResult);
          }

          key[hashAttr.AttributeName] = {'B': data[1]};
          break;
        }
        default:
          throw new DaxClientError(`Hash key must be S, B or N, instead key is: ${hashAttr}`, DaxErrorCode.MalformedResult);
      }

      if(ref.offset < 0 || ref.offset >= keyBytes.length) {
        throw new DaxClientError(`Offset is out of range: 0 <= ${ref.offset} < ${keyBytes.length}`, DaxErrorCode.MalformedResult);
      }

      let rangeAttr = keySchema[1];
      let rangeBytes = keyBytes.slice(ref.offset);

      switch(rangeAttr.AttributeType) {
        case 'S':
          key[rangeAttr.AttributeName] = {'S': rangeBytes.toString('utf-8')};
          break;
        case 'N': {
          let ref = [];
          LexDecimal.decode(rangeBytes, 0, ref);
          key[rangeAttr.AttributeName] = {'N': ref[0].toString()};
          break;
        }
        case 'B':
          key[rangeAttr.AttributeName] = {'B': rangeBytes};
          break;
        default:
          throw new DaxClientError(`Range key must be S, B or N, instead key is: ${rangeAttr}`, DaxErrorCode.MalformedResult);
      }
    } else {
      throw new DaxClientError(`Key schema must be of length 1 or 2; got ${keySchema.length} (${keySchema})`, DaxErrorCode.MalformedResult);
    }

    return key;
  }

  * _decodeKeyBytes() {
    return yield* Assembler._decodeKeyBytes(this._keySchema);
  }

  * _decodeCompoundKey() {
    let ckArr = CborDecoder.decodeAllSync(yield* this._getBinary());
    if(ckArr[0][0] === CborTypes.RET_NULL) {
      return null;
    }

    if(ckArr[0][0] !== CborTypes.RET_MAP_HEADER) {
      throw new DaxClientError('Unknown compound key', DaxErrorCode.MalformedResult);
    }

    let ck = {};
    let i = 1;
    while(i < ckArr.length) {
      if(ckArr[i][0] === CborTypes.RET_STREAM_BREAK) {
        break;
      }

      let name = ckArr[i++][1];

      ck[name] = {[CborToDDBMaping[ckArr[i][0]]]: ckArr[i][1]};
      i++;
    }

    return ck;
  }

  * _decodeScanValue() {
    let item = this._decodeStreamItem(yield* this._getBinary());
    return item;
  }

  * _decodeStreamItemAsync() {
    let data = (yield)[1];
    return this._decodeStreamItem(data);
  }

  * _decodeConsumedCapacity() {
    let consumedCapacity = {};
    let byteheader = yield;
    if(byteheader[0] === CborTypes.RET_NULL) {
      return null;
    }
    let objlist = convertArrToObjList(CborDecoder.decodeAllSync(yield* this._getBinary()));
    // should contain a string, a number, a null or a number, two (map or null).
    consumedCapacity.TableName = objlist[0];
    consumedCapacity.CapacityUnits = objlist[1];
    if(objlist[2] !== null) {
      consumedCapacity.Table = {CapacityUnits: objlist[2]};
    }

    consumedCapacity.GlobalSecondaryIndexes = this._decodeIndexConsumedCapacity(objlist[3]);
    consumedCapacity.LocalSecondaryIndexes = this._decodeIndexConsumedCapacity(objlist[4]);
  }

  _decodeIndexConsumedCapacity(obj) {
    if(obj) {
      for(let key in obj) {
        if(Object.prototype.hasOwnProperty.call(obj, key)) {
          obj[key] = {CapacityUnits: obj[key]};
        }
      }
    }
    return obj;
  }

  * _decodeItemCollectionMetrics(keys) {
    let data = yield;
    if(data[0] === CborTypes.RET_NULL) {
      return null;
    }

    keys = keys || this._keySchema;

    let itemCollectionMetrics = {};
    let arr = CborDecoder.decodeAllSync(data[1]);
    itemCollectionMetrics.ItemCollectionKey = {[keys[0].AttributeName]: arr[0][1]};
    itemCollectionMetrics.SizeEstimateRangeGB = [arr[1][1], arr[2][1]];
    return itemCollectionMetrics;
  }

  * _decodeCount() {
    return yield* this._getInt();
  }

  * _decodeScannedCount() {
    return yield* this._getInt();
  }

  * _decodeLastEvaluatedKey() {
    if(this._request.IndexName) {
      return yield* this._decodeCompoundKey();
    } else {
      return yield* this._decodeKeyBytes();
    }
  }

  * _getInt() { // Caution! will return number instead of string
    let data = yield;
    if(data[0] !== CborTypes.RET_INT) {
      throw new DaxClientError('not a Int returned', DaxErrorCode.MalformedResult);
    }
    return parseInt(data[1]);
  }

  * _getString() {
    let data = yield;
    if(data[0] !== CborTypes.RET_UTF) {
      throw new DaxClientError('not a String returned', DaxErrorCode.MalformedResult);
    }
    return data[1];
  }

  * _getBinary() {
    let data = yield;
    if(data[0] !== CborTypes.RET_BUF) {
      throw new DaxClientError('not a Binary returned', DaxErrorCode.MalformedResult);
    }
    return data[1];
  }

  * _getArrayHeader() {
    let data = yield;
    if(data[0] !== CborTypes.RET_ARR_HEADER) {
      throw new DaxClientError('not an array header returned', DaxErrorCode.MalformedResult);
    }
    return data[1];
  }

  * _getMapHeader() {
    let data = yield;
    if(data[0] !== CborTypes.RET_MAP_HEADER) {
      throw new DaxClientError('not a map header returned', DaxErrorCode.MalformedResult);
    }
    return data[1];
  }
};

