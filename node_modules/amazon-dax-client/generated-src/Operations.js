/* eslint max-len: ["off"] no-unused-vars: ["off"] padded-blocks: ["off"] */
/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not
 * use this file except in compliance with the License. A copy of the License
 * is located at
 *
 *    http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
'use strict';

const BaseOperations = require('../src/BaseOperations');
const CborDecoder = require('../src/CborDecoder');
const AttributeValueEncoder = require('../src/AttributeValueEncoder');
const Stubs = require('./Stubs');
const Assemblers = require('./Assemblers');
const DaxMethodIds = require('../src/Constants').DaxMethodIds;
const DynamoDBV1Converter = require('../src/DynamoDBV1Converter');


module.exports = class Operations extends BaseOperations {
  constructor(keyCache, attrListCache, attrListIdCache, tubePool) {
    super(keyCache, attrListCache, attrListIdCache, tubePool);
  }

  batchGetItem_N697851100_1(ddbRequest) {
    // Pre-process requests, including V1-V2 conversion
    let request = DynamoDBV1Converter.convertRequest(ddbRequest, DaxMethodIds.batchGetItem);

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      // Use a custom preparation for batchGetItem
      .then((data) => this.prepare_batchGetItem_N697851100_1(request))
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.batchGetItem_N697851100_1_Assembler(request);

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            this.write_batchGetItem_N697851100_1(data, tube);

            return returnHandler;
          });
      });
  }

  batchWriteItem_116217951_1(ddbRequest) {
    // Pre-process requests, including V1-V2 conversion
    let request = DynamoDBV1Converter.convertRequest(ddbRequest, DaxMethodIds.batchWriteItem);

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      // Use a custom preparation for batchWriteItem
      .then((data) => this.prepare_batchWriteItem_116217951_1(request))
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.batchWriteItem_116217951_1_Assembler(request);

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            this.write_batchWriteItem_116217951_1(data, tube);

            return returnHandler;
          });
      });
  }

  defineAttributeList_670678385_1(attributeListId) {

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.defineAttributeList_670678385_1_Assembler();

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_defineAttributeList_670678385_1(attributeListId, tube);

            return returnHandler;
          });
      });
  }

  defineAttributeListId_N1230579644_1(attributeNames) {

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.defineAttributeListId_N1230579644_1_Assembler();

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_defineAttributeListId_N1230579644_1(attributeNames, tube);

            return returnHandler;
          });
      });
  }

  defineKeySchema_N742646399_1(tableName) {

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.defineKeySchema_N742646399_1_Assembler();

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_defineKeySchema_N742646399_1(tableName, tube);

            return returnHandler;
          });
      });
  }

  deleteItem_1013539361_1(ddbRequest) {
    // Pre-process requests, including V1-V2 conversion
    let request = DynamoDBV1Converter.convertRequest(ddbRequest, DaxMethodIds.deleteItem);

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      // Precache the key to avoid parallel calls
      .then((data) => {
        return this.keyCache.get(request.TableName)
          .then((keySchema) => { data.keySchema = keySchema; return data; });
      })
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.deleteItem_1013539361_1_Assembler(request, data.keySchema);

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_deleteItem_1013539361_1(request, data.keySchema, tube);

            return returnHandler;
          })
          .then((result) => {
            // Resolve any attribute values not in the cache
            return this._resolveAttributeValues(result);
          });
      });
  }

  endpoints_455855874_1() {

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.endpoints_455855874_1_Assembler();

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_endpoints_455855874_1(tube);

            return returnHandler;
          });
      });
  }

  getItem_263244906_1(ddbRequest) {
    // Pre-process requests, including V1-V2 conversion
    let request = DynamoDBV1Converter.convertRequest(ddbRequest, DaxMethodIds.getItem);

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      // Precache the key to avoid parallel calls
      .then((data) => {
        return this.keyCache.get(request.TableName)
          .then((keySchema) => { data.keySchema = keySchema; return data; });
      })
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.getItem_263244906_1_Assembler(request, data.keySchema);

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_getItem_263244906_1(request, data.keySchema, tube);

            return returnHandler;
          })
          .then((result) => {
            // Resolve any attribute values not in the cache
            return this._resolveAttributeValues(result);
          });
      });
  }

  putItem_N2106490455_1(ddbRequest) {
    // Pre-process requests, including V1-V2 conversion
    let request = DynamoDBV1Converter.convertRequest(ddbRequest, DaxMethodIds.putItem);

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      // Precache the key to avoid parallel calls
      .then((data) => {
        return this.keyCache.get(request.TableName)
          .then((keySchema) => { data.keySchema = keySchema; return data; });
      })
      // Precache the attribute list ID to avoid parallel calls
      .then((data) => {
        let attrNames = AttributeValueEncoder.getCanonicalAttributeList(request.Item, data.keySchema);
        return this.attrListIdCache.get(attrNames)
          .then((attrListId) => { data.attrNames = attrNames; data.attrListId = attrListId; return data; });
      })
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.putItem_N2106490455_1_Assembler(request, data.keySchema);

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_putItem_N2106490455_1(request, data.keySchema, data.attrNames, data.attrListId, tube);

            return returnHandler;
          })
          .then((result) => {
            // Resolve any attribute values not in the cache
            return this._resolveAttributeValues(result);
          });
      });
  }

  query_N931250863_1(ddbRequest) {
    // Pre-process requests, including V1-V2 conversion
    let request = DynamoDBV1Converter.convertRequest(ddbRequest, DaxMethodIds.query);

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      // Precache the key to avoid parallel calls
      .then((data) => {
        return this.keyCache.get(request.TableName)
          .then((keySchema) => { data.keySchema = keySchema; return data; });
      })
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.query_N931250863_1_Assembler(request, data.keySchema);

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_query_N931250863_1(request, data.keySchema, tube);

            return returnHandler;
          })
          .then((result) => {
            // Resolve any attribute values not in the cache
            return this._resolveAttributeValues(result);
          });
      });
  }

  scan_N1875390620_1(ddbRequest) {
    // Pre-process requests, including V1-V2 conversion
    let request = DynamoDBV1Converter.convertRequest(ddbRequest, DaxMethodIds.scan);

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      // Precache the key to avoid parallel calls
      .then((data) => {
        return this.keyCache.get(request.TableName)
          .then((keySchema) => { data.keySchema = keySchema; return data; });
      })
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.scan_N1875390620_1_Assembler(request, data.keySchema);

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_scan_N1875390620_1(request, data.keySchema, tube);

            return returnHandler;
          })
          .then((result) => {
            // Resolve any attribute values not in the cache
            return this._resolveAttributeValues(result);
          });
      });
  }

  updateItem_1425579023_1(ddbRequest) {
    // Pre-process requests, including V1-V2 conversion
    let request = DynamoDBV1Converter.convertRequest(ddbRequest, DaxMethodIds.updateItem);

    // Start with an empty object for storing data, to avoid null exceptions
    return Promise.resolve({})
      // Precache the key to avoid parallel calls
      .then((data) => {
        return this.keyCache.get(request.TableName)
          .then((keySchema) => { data.keySchema = keySchema; return data; });
      })
      .then((data) => {
        let decoder = new CborDecoder();
        let assembler = new Assemblers.updateItem_1425579023_1_Assembler(request, data.keySchema);

        return this.tubePool.alloc()
          .then((tube) => tube.reauth())
          .then((tube) => {
            // Send the actual request
            tube.socket.pipe(decoder).pipe(assembler);

            // Wrap the assembler result in a promise
            let returnHandler = this._getReturnHandler(tube, decoder, assembler);

            Stubs.write_updateItem_1425579023_1(request, data.keySchema, tube);

            return returnHandler;
          })
          .then((result) => {
            // Resolve any attribute values not in the cache
            return this._resolveAttributeValues(result);
          });
      });
  }

};
