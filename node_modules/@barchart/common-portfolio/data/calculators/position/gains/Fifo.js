const log4js = require('log4js');

const Decimal = require('@barchart/common-js/lang/Decimal'),
	Queue = require('@barchart/common-js/collections/Queue');

const GainLoss = require('./GainLoss');

module.exports = (() => {
	'use strict';

	const logger = log4js.getLogger('portfolio-common/data/calculators/position/gains/Fifo');

	/**
	 * A gain (or loss) calculation strategy that uses a first-in,
	 * first-out methodology.
	 *
	 * @public
	 * @extends {GainLoss}
	 */
	class Fifo extends GainLoss {
		constructor() {
			super();

			this._totalGain = Decimal.ZERO;

			this._queue = new Queue();
		}

		_calculate(transaction, currency) {
			let totalOpeningAmount;
			let totalClosingAmount;

			const type = transaction.type;

			if (type.opening) {
				const openingQuantity = transaction.quantity;
				const openingAmount = transaction.amount;
				const openingRate = openingAmount.divide(openingQuantity);

				const openingData = {
					quantity: openingQuantity,
					amount: openingAmount,
					rate: openingRate
				};

				this._queue.enqueue(openingData);

				totalOpeningAmount = Decimal.ZERO;
				totalClosingAmount = Decimal.ZERO;
			} else if (type.closing) {
				let quantityToClose = transaction.quantity;
				let amountOpened = Decimal.ZERO;

				while (!quantityToClose.getIsZero()) {
					let open = this._queue.peek();

					const openingQuantity = open.quantity;
					const openingAmount = open.amount;
					const openingRate = open.rate;

					const eliminationTest = openingQuantity.add(quantityToClose);

					let eliminationQuantity;
					let eliminationAmount;

					if (openingQuantity.getIsPositive() ^ eliminationTest.getIsPositive()) {
						eliminationQuantity = openingQuantity;
						eliminationAmount = openingAmount;

						this._queue.dequeue();
					} else {
						eliminationQuantity = quantityToClose.opposite();
						eliminationAmount = eliminationQuantity.multiply(openingRate).round(2, Decimal.ROUNDING_MODE.NORMAL);

						open.quantity = openingQuantity.subtract(eliminationQuantity);
						open.amount = openingAmount.subtract(eliminationAmount);
					}

					quantityToClose = quantityToClose.add(eliminationQuantity);
					amountOpened = amountOpened.add(eliminationAmount);
				}

				totalOpeningAmount = amountOpened;
				totalClosingAmount = transaction.amount;
			}

			let remainingOpenQuantity = Decimal.ZERO;
			let remainingOpenAmount = Decimal.ZERO;

			if (!this._queue.empty()) {
				this._queue.scan((open) => {
					remainingOpenQuantity = remainingOpenQuantity.add(open.quantity);
					remainingOpenAmount = remainingOpenAmount.add(open.amount);
				});
			}

			if (type.opening || type.closing) {
				const transactionGain = totalClosingAmount.add(totalOpeningAmount);

				this._totalGain = this._totalGain.add(transactionGain);
			}

			let basis;

			if (remainingOpenQuantity.getIsZero()) {
				basis = Decimal.ZERO;
			} else {
				basis = remainingOpenAmount;
			}

			return GainLoss.format(remainingOpenQuantity, basis, this._totalGain);
		}

		toString() {
			return '[Fifo]';
		}
	}

	return Fifo;
})();