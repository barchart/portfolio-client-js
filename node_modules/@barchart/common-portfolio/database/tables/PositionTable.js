const log4js = require('log4js');

const assert = require('@barchart/common-js/lang/assert'),
	Currency = require('@barchart/common-js/lang/Currency'),
	is = require('@barchart/common-js/lang/is');

const DataType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/DataType'),
	DynamoProvider = require('@barchart/common-node-js/aws/DynamoProvider'),
	IndexType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/IndexType'),
	KeyType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/KeyType'),
	OrderingType = require('@barchart/common-node-js/aws/dynamo/query/definitions/OrderingType'),
	OperatorType = require('@barchart/common-node-js/aws/dynamo/query/definitions/OperatorType'),
	ProjectionType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/ProjectionType'),
	QueryBuilder = require('@barchart/common-node-js/aws/dynamo/query/builders/QueryBuilder'),
	TableContainer = require('@barchart/common-node-js/aws/dynamo/TableContainer');

const InstrumentType = require('./../../data/InstrumentType'),
	ValuationType = require('./../../data/ValuationType');

const PositionSchema = require('./../../data/serialization/json/PositionSchema');

module.exports = (() => {
	'use strict';

	const logger = log4js.getLogger('portfolio-common/database/tables/PositionTable');

	/**
	 * A DynamoDB table for positions, which are owned by portfolios.
	 *
	 * @public
	 * @extends {TableContainer}
	 */
	class PositionTable extends TableContainer {
		constructor(dynamoProvider) {
			super(dynamoProvider, getTableSchema(dynamoProvider));
		}

		/**
		 * Saves a position. If an existing position shares the same key(s), the
		 * promise will be rejected.
		 *
		 * @public
		 * @param {Position} position
		 * @returns {Promise}
		 */
		createPosition(position) {
			return this._createItem(position, true);
		}

		/**
		 * Saves a position. If existing position shares the same key(s), it
		 * will be overwritten.
		 *
		 * @public
		 * @param {Position} position
		 * @returns {Promise}
		 */
		updatePosition(position) {
			return this._createItem(position, false);
		}

		/**
		 * Retrieves positions within a portfolio.
		 *
		 * @public
		 * @param {String} portfolio
		 * @returns {Promise<Portfolio[]>}
		 */
		getPositions(portfolio, instrument, open) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(portfolio, 'portfolio', String);

					let builder = QueryBuilder.targeting(this.definition)
						.withDescription(`get positions for portfolio [ ${portfolio} ]`)
						.withKeyFilterBuilder((kfb) => {
							kfb.withExpression('portfolio', OperatorType.EQUALS, portfolio);
						});

					return this.query(builder.query);
				});
		}

		/**
		 * Queries positions within a portfolio.
		 *
		 * @public
		 * @param {String} portfolio
		 * @param {PositionSchema=} schema - The schema used to determine which fields are projected into the results.
		 * @param {number=} limit - The maximum number of results.
		 * @param {descending=} descending - If true, the results will be returned in descending order.
		 * @returns {Promise<Portfolio[]>}
		 */
		queryPositions(portfolio, schema, limit, descending) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(portfolio, 'portfolio', String);

					let builder = QueryBuilder.targeting(this.definition)
						.withDescription(`get positions for portfolio [ ${portfolio} ]`)
						.withKeyFilterBuilder((kfb) => {
							kfb.withExpression('portfolio', OperatorType.EQUALS, portfolio);
						});

					if (is.number(limit)) {
						builder.withLimit(limit);
					}

					if (is.boolean(descending) && descending) {
						builder.withOrderingType(OrderingType.DESCENDING);
					}

					if (schema) {
						schema.schema.fields.forEach(field => builder.withAttribute(field.name));
					}

					return this.query(builder.query);
				});
		}
	}

	function getTableSchema(dynamoProvider) {
		return dynamoProvider.getTableBuilder('position')
			.withProvisionedThroughput(100, 100)
			.withAttribute('user', DataType.STRING)
			.withAttribute('portfolio', DataType.STRING)
			.withAttribute('sequence', DataType.NUMBER)
			.withAttribute('instrument.id', DataType.STRING)
			.withAttribute('instrument.name', DataType.STRING)
			.withAttribute('instrument.type', DataType.forEnum(InstrumentType, 'InstrumentType'))
			.withAttribute('instrument.currency', DataType.forEnum(Currency, 'Currency'))
			.withAttribute('instrument.delist', DataType.DAY)
			.withAttribute('instrument.symbol.barchart', DataType.STRING)
			.withAttribute('instrument.symbol.display', DataType.STRING)
			.withAttribute('position', DataType.STRING)
			/*
			.withAttributeBuilder('position', (ab) => {
				ab.withDataType(DataType.STRING)
					.withDerivationBuilder((db) => {
						db.withAttribute('instrument.id')
							.withAttribute('sequence')
							.withGenerator(data => getPositionKey(data[0], data[1]));
					});
			})
			*/
			.withAttribute('open', DataType.BOOLEAN)
			.withAttribute('transaction', DataType.NUMBER)
			.withAttribute('valuation', DataType.forEnum(ValuationType, 'ValuationType'))
			.withAttribute('reinvest', DataType.BOOLEAN)
			.withAttribute('snapshot.date', DataType.DAY)
			.withAttribute('snapshot.open', DataType.DECIMAL)
			.withAttribute('snapshot.buys', DataType.DECIMAL)
			.withAttribute('snapshot.sells', DataType.DECIMAL)
			.withAttribute('snapshot.gain', DataType.DECIMAL)
			.withAttribute('snapshot.basis', DataType.DECIMAL)
			.withAttribute('snapshot.income', DataType.DECIMAL)
			.withAttribute('snapshot.value', DataType.DECIMAL)
			.withAttribute('legacy.system', DataType.STRING)
			.withAttribute('legacy.user', DataType.STRING)
			.withAttribute('legacy.portfolio', DataType.STRING)
			.withAttribute('legacy.position', DataType.STRING)
			.withAttribute('system.version', DataType.NUMBER)
			.withKey('portfolio', KeyType.HASH)
			.withKey('position', KeyType.RANGE)
			.withIndexBuilder('for-instruments', (ib) => {
				ib.withType(IndexType.GLOBAL_SECONDARY)
					.withKey('instrument.symbol.barchart', KeyType.HASH)
					.withKey('position', KeyType.RANGE)
					.withProjection(ProjectionType.KEYS)
					.withProvisionedThroughput(100, 100);
			})
			.table;
	}

	function getPositionKey(id, sequence) {
		return `${id}-${sequence}`;
	}

	/**
	 * Metadata for an instrument (which can be held as a {@link Position}
	 * in a {@link Portfolio}).
	 *
	 * @typedef Instrument
	 * @type {Object}
	 * @property {String} id - The unique identifier for the instrument.
	 * @property {String} name - The name of the instrument (for display purposes).
	 * @property {InstrumentType} type - The instrument type.
	 * @property {Currency} currency - The currency the instrument is traded and valued in.
	 * @property {Day=} delist - The date the instrument is delisted (or more generally, becomes invalid).
	 * @property {Object=} symbol - An object that contains data about the instrument's symbology.
	 * @property {String=} symbol.display - The symbol for use in user interfaces and report.
	 * @property {String=} symbol.barchart - The symbol to use for querying Barchart systems.
	 */

	/**
	 * The state of a {@link Position}.
	 *
	 * @typedef Snapshot
	 * @type {Object}
	 * @property {ValuationType} type - The methodology used to perform the valuation.
	 * @property {Decimal} open - The current (signed) size of the position.
	 * @property {Decimal} gain - The realized gain (signed) on the position.
	 * @property {Decimal} basis - The current basis (signed) on the position.
	 */

	/**
	 * A position.
	 *
	 * @typedef Position
	 * @type {Object}
	 * @property {String} user - The identifier for the owner of the portfolio.
	 * @property {String} portfolio - The identifier of the portfolio the position belongs to.
	 * @property {String} position - An identifier for the position.
	 * @property {Number} sequence - The sequence number for the position.
	 * @property {Instrument} instrument - The instrument.
	 * @property {Boolean} open - Indicates if the position is open (or closed).
	 * @property {Number} transaction - The sequence number of the most recent transaction.
	 * @property {ValuationType} valuation - The valuation strategy used for the position.
	 * @property {Boolean} reinvest - Indicates if dividends, distributions, or income are re-invested into the position.
	 * @property {Snapshot} snapshot - The position snapshot (as of the most recently processed transaction).
	 */

	return PositionTable;
})();