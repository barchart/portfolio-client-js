const log4js = require('log4js');

const assert = require('@barchart/common-js/lang/assert'),
	Currency = require('@barchart/common-js/lang/Currency'),
	Timezones = require('@barchart/common-js/lang/Timezones');

const DataType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/DataType'),
	DynamoProvider = require('@barchart/common-node-js/aws/DynamoProvider'),
	IndexType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/IndexType'),
	KeyType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/KeyType'),
	OperatorType = require('@barchart/common-node-js/aws/dynamo/query/definitions/OperatorType'),
	ProjectionType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/ProjectionType'),
	QueryBuilder = require('@barchart/common-node-js/aws/dynamo/query/builders/QueryBuilder'),
	TableContainer = require('@barchart/common-node-js/aws/dynamo/TableContainer');

const ValuationType = require('./../../data/ValuationType');

module.exports = (() => {
	'use strict';

	const logger = log4js.getLogger('portfolio-common/database/tables/PortfolioTable');

	/**
	 * A DynamoDB table for portfolios, which are held by users.
	 *
	 * @public
	 * @extends {TableContainer}
	 */
	class PortfolioTable extends TableContainer {
		constructor(dynamoProvider) {
			super(dynamoProvider, getTableSchema(dynamoProvider));
		}

		/**
		 * Saves a portfolio. If an existing portfolio shares the same key(s), the
		 * promise will be rejected.
		 *
		 * @public
		 * @param {Portfolio} portfolio
		 * @returns {Promise}
		 */
		createPortfolio(portfolio) {
			return this._createItem(portfolio, true);
		}

		/**
		 * Saves a portfolio. If existing portfolio shares the same key(s), it
		 * will be overwritten.
		 *
		 * @public
		 * @param {Portfolio} portfolio
		 * @returns {Promise}
		 */
		updatePortfolio(portfolio) {
			return this._createItem(portfolio, false);
		}

		/**
		 * Retrieves all portfolios for a user.
		 *
		 * @public
		 * @param {String} user
		 * @returns {Promise<Portfolio[]>}
		 */
		getPortfolios(user) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(user, 'user', String);

					let builder = QueryBuilder.targeting(this.definition)
						.withDescription(`get portfolios for user [ ${user} ]`)
						.withKeyFilterBuilder((kfb) => {
							kfb.withExpression('user', OperatorType.EQUALS, user);
						});

					return this.query(builder.query);
				});
		}

		/**
		 * Retrieves a single portfolio.
		 *
		 * @public
		 * @param {String} user
		 * @param {String} portfolio
		 * @returns {Promise<Portfolio|null>}
		 */
		getPortfolio(user, portfolio) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(user, 'user', String);

					let builder = QueryBuilder.targeting(this.definition)
						.withDescription(`get portfolios for user [ ${user} ]`)
						.withKeyFilterBuilder((kfb) => {
							kfb.withExpression('user', OperatorType.EQUALS, user)
								.withExpression('portfolio', OperatorType.EQUALS, portfolio);
						});

					return this.query(builder.query);
				}).then((portfolios) => {
					if (portfolios.length === 1) {
						return portfolios[0];
					} else {
						return null;
					}
				});
		}

		queryPortfoliosForLegacyUser(user) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(user, 'user', String);

					let builder = QueryBuilder.targeting(this.definition)
						.withIndex('for-legacy-user')
						.withDescription(`get legacy portfolios for user [ ${user} ]`)
						.withKeyFilterBuilder((kfb) => {
							kfb.withExpression('legacy.user', OperatorType.EQUALS, user);
						});

					return this.query(builder.query);
				});
		}

		toString() {
			return '[PortfolioTable]';
		}
	}

	function getTableSchema(dynamoProvider) {
		return dynamoProvider.getTableBuilder('portfolio')
			.withProvisionedThroughput(10, 100)
			.withAttribute('user', DataType.STRING, KeyType.HASH)
			.withAttribute('portfolio', DataType.STRING, KeyType.RANGE)
			.withAttribute('name', DataType.STRING)
			.withAttribute('timezone', DataType.forEnum(Timezones, 'Timezone'))
			.withAttribute('dates.create', DataType.DAY)
			.withAttribute('dates.cash', DataType.DAY)
			.withAttribute('defaults.currency', DataType.forEnum(Currency, 'Currency'))
			.withAttribute('defaults.reinvest', DataType.BOOLEAN)
			.withAttribute('defaults.valuation', DataType.forEnum(ValuationType, 'ValuationType'))
			.withAttribute('legacy.system', DataType.STRING)
			.withAttribute('legacy.user', DataType.STRING)
			.withAttribute('legacy.portfolio', DataType.STRING)
			.withAttribute('legacy.warnings', DataType.NUMBER)
			.withAttribute('legacy.drops', DataType.NUMBER)
			.withAttribute('system.version', DataType.NUMBER)
			.withIndexBuilder('for-legacy-user', (ib) => {
				ib.withType(IndexType.GLOBAL_SECONDARY)
					.withKey('legacy.user', KeyType.HASH)
					.withKey('portfolio', KeyType.RANGE)
					.withProjection(ProjectionType.ALL)
					.withProvisionedThroughput(10, 100);
			})
			.table;
	}

	/**
	 * A portfolio
	 *
	 * @public
	 * @typedef Portfolio
	 * @type {Object}
	 * @property {String} user - The portfolio owner.
	 * @property {String} portfolio - The portfolio identifier.
	 */

	return PortfolioTable;
})();