const log4js = require('log4js');

const assert = require('@barchart/common-js/lang/assert'),
	Day = require('@barchart/common-js/lang/Day'),
	is = require('@barchart/common-js/lang/is'),
	string = require('@barchart/common-js/lang/string');

const DataType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/DataType'),
	DynamoProvider = require('@barchart/common-node-js/aws/DynamoProvider'),
	IndexType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/IndexType'),
	KeyType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/KeyType'),
	OrderingType = require('@barchart/common-node-js/aws/dynamo/query/definitions/OrderingType'),
	OperatorType = require('@barchart/common-node-js/aws/dynamo/query/definitions/OperatorType'),
	ProjectionType = require('@barchart/common-node-js/aws/dynamo/schema/definitions/ProjectionType'),
	QueryBuilder = require('@barchart/common-node-js/aws/dynamo/query/builders/QueryBuilder'),
	TableContainer = require('@barchart/common-node-js/aws/dynamo/TableContainer');

const TransactionSchema = require('./../../data/serialization/json/TransactionSchema'),
	TransactionType = require('./../../data/TransactionType');

module.exports = (() => {
	'use strict';

	const logger = log4js.getLogger('portfolio-common/database/tables/TransactionTable');

	/**
	 * A DynamoDB table for transactions (which compose positions).
	 *
	 * @public
	 * @extends {TableContainer}
	 */
	class TransactionTable extends TableContainer {
		constructor(dynamoProvider) {
			super(dynamoProvider, getTableSchema(dynamoProvider));
		}

		/**
		 * Saves a transaction. If an existing portfolio shares the same key(s), the
		 * promise will be rejected.
		 *
		 * @public
		 * @param {Transaction} transaction
		 * @returns {Promise}
		 */
		createTransaction(transaction) {
			return this._createItem(transaction, true);
		}

		/**
		 * Returns all the transactions that compose a position.
		 *
		 * @param {string} portfolio - The portfolio identifier.
		 * @param {string} position - The position identifier.
		 * @returns {Promise.<Transaction[]>}
		 */
		getTransactions(portfolio, position) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(portfolio, 'portfolio', String);
					assert.argumentIsRequired(position, 'position', String);

					const builder = QueryBuilder.targeting(this.definition)
						.withDescription(`get transactions for portfolio [ ${portfolio}/${position} ]`)
						.withKeyFilterBuilder((kfb) => {
							kfb.withExpression('key.position', OperatorType.EQUALS, getPositionKey(portfolio, position));
						});

					return this.query(builder.query);
				});
		}

		/**
		 * Queries transactions for a single position.
		 *
		 * @param {string} portfolio - The portfolio identifier.
		 * @param {string} position - The position identifier.
		 * @param {TransactionSchema=} schema - The schema used to determine which fields are projected into the results.
		 * @param {number=} limit - The maximum number of results.
		 * @param {descending=} descending - If true, the results will be returned in descending order.
		 * @returns {Promise.<Transaction[]>}
		 */
		queryTransactionsForPosition(portfolio, position, schema, limit, descending) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(portfolio, 'portfolio', String);
					assert.argumentIsRequired(position, 'position', String);
					assert.argumentIsOptional(schema, 'schema', TransactionSchema, 'TransactionSchema');
					assert.argumentIsOptional(limit, 'limit', Number);
					assert.argumentIsOptional(descending, 'descending', Boolean);

					const builder = QueryBuilder.targeting(this.definition)
						.withDescription(`query transactions for portfolio [ ${portfolio}/${position} ]`)
						.withKeyFilterBuilder((kfb) => {
							kfb.withExpression('key.position', OperatorType.EQUALS, getPositionKey(portfolio, position));
						});

					if (is.number(limit)) {
						builder.withLimit(limit);
					}

					if (is.boolean(descending) && descending) {
						builder.withOrderingType(OrderingType.DESCENDING);
					}

					if (schema) {
						schema.schema.fields.forEach(field => builder.withAttribute(field.name));
					}

					return this.query(builder.query);
				});
		}

		/**
		 * Queries transactions for a portfolio (i.e. many positions) using global secondary index.
		 *
		 * @param {string} portfolio - The portfolio identifier.
		 * @param {TransactionSchema=} schema - The schema used to determine which fields are projected into the results.
		 * @param {Day=} start - The first day to return transactions for.
		 * @param {Day=} end - The last day to return transactions for.
		 * @param {number=} limit - The maximum number of results.
		 * @param {descending=} descending - If true, the results will be returned in descending order.
		 * @returns {Promise.<Transaction[]>}
		 */
		queryTransactionsForPortfolio(portfolio, schema, start, end, limit, descending) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(portfolio, 'portfolio', String);
					assert.argumentIsOptional(schema, 'schema', TransactionSchema, 'TransactionSchema');
					assert.argumentIsOptional(limit, 'limit', Number);
					assert.argumentIsOptional(descending, 'descending', Boolean);

					const builder = QueryBuilder.targeting(this.definition)
						.withIndex(INDEX_BY_PORTFOLIO_AND_DATE)
						.withDescription(`query transactions for portfolio [ ${portfolio} ]`)
						.withKeyFilterBuilder((kfb) => {
							kfb.withExpression('portfolio', OperatorType.EQUALS, portfolio);

							if (start) {
								kfb.withExpression('key.date', OperatorType.GREATER_THAN_OR_EQUAL_TO, start.format());
							}

							if (end) {
								kfb.withExpression('key.date', OperatorType.LESS_THAN_OR_EQUAL_TO, end.format());
							}
						});

					if (is.number(limit)) {
						builder.withLimit(limit);
					}

					if (is.boolean(descending) && descending) {
						builder.withOrderingType(OrderingType.DESCENDING);
					}

					if (schema) {
						schema.schema.fields.forEach(field => builder.withAttribute(field.name));
					}

					return this.query(builder.query);
				});
		}
	}

	const INDEX_BY_PORTFOLIO_AND_DATE = 'transactions-by-portfolio-and-date';

	function getTableSchema(dynamoProvider) {
		return dynamoProvider.getTableBuilder('transaction')
			.withProvisionedThroughput(100, 300)
			.withAttribute('user', DataType.STRING)
			.withAttribute('portfolio', DataType.STRING)
			.withAttribute('position', DataType.STRING)
			.withAttribute('sequence', DataType.NUMBER)
			.withAttributeBuilder('key.position', (ab) => {
				ab.withDataType(DataType.STRING)
					.withDerivationBuilder((db) => {
						db.withAttribute('portfolio')
							.withAttribute('position')
							.withGenerator(data => getPositionKey(data[0], data[1]));
					});
			})
			.withAttribute('type', DataType.forEnum(TransactionType, 'TransactionType'))
			.withAttribute('date', DataType.DAY)
			.withAttribute('description', DataType.STRING)
			.withAttributeBuilder('key.date', (ab) => {
				ab.withDataType(DataType.STRING)
					.withDerivationBuilder((db) => {
						db.withAttribute('date')
							.withAttribute('position')
							.withAttribute('sequence')
							.withGenerator((data) => `${data[0].format()}.${data[1]}.${string.padLeft(data[2].toString(), 8, '0')}`);
					});
			})
			.withAttribute('timestamp', DataType.TIMESTAMP)
			.withAttribute('amount', DataType.DECIMAL)
			.withAttribute('quantity', DataType.DECIMAL)
			.withAttribute('fee', DataType.DECIMAL)
			.withAttribute('reference.position', DataType.STRING)
			.withAttribute('reference.sequence', DataType.NUMBER)
			.withAttribute('snapshot.open', DataType.DECIMAL)
			.withAttribute('snapshot.buys', DataType.DECIMAL)
			.withAttribute('snapshot.sells', DataType.DECIMAL)
			.withAttribute('snapshot.gain', DataType.DECIMAL)
			.withAttribute('snapshot.basis', DataType.DECIMAL)
			.withAttribute('snapshot.income', DataType.DECIMAL)
			.withAttribute('snapshot.value', DataType.DECIMAL)
			.withAttribute('legacy.system', DataType.STRING)
			.withAttribute('legacy.user', DataType.STRING)
			.withAttribute('legacy.portfolio', DataType.STRING)
			.withAttribute('legacy.position', DataType.STRING)
			.withAttribute('legacy.transaction', DataType.STRING)
			.withAttribute('trade.price', DataType.DECIMAL)
			.withAttribute('dividend.rate', DataType.DECIMAL)
			.withAttribute('dividend.effective', DataType.DAY)
			.withAttribute('dividend.price', DataType.DECIMAL)
			.withAttribute('dividend.amount', DataType.DECIMAL)
			.withAttribute('split.numerator', DataType.DECIMAL)
			.withAttribute('split.denominator', DataType.DECIMAL)
			.withAttribute('split.effective', DataType.DAY)
			.withAttribute('charge.amount', DataType.DECIMAL)
			.withAttribute('income.amount', DataType.DECIMAL)
			.withAttribute('valuation.value', DataType.DECIMAL)
			.withKey('key.position', KeyType.HASH)
			.withKey('sequence', KeyType.RANGE)
			.withIndexBuilder(INDEX_BY_PORTFOLIO_AND_DATE, (ib) => {
				ib.withType(IndexType.GLOBAL_SECONDARY)
					.withKey('portfolio', KeyType.HASH)
					.withKey('key.date', KeyType.RANGE)
					.withProjection(ProjectionType.ALL)
					.withProvisionedThroughput(100, 300);
			})
			.table;
	}

	function getPositionKey(portfolio, position) {
		return `${portfolio}.${position}`;
	}

	/**
	 * A transaction.
	 *
	 * @typedef Transaction
	 * @type {Object}
	 * @property {String} portfolio - The identifier of the portfolio.
	 * @property {String} position - The identifier of the position.
	 * @property {Number} sequence - The transaction sequence.
	 * @property {TransactionType} type - The transaction type.
	 */

	return TransactionTable;
})();
