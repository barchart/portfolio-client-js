const assert = require('@barchart/common-js/lang/assert'),
	CompoundMap = require('@barchart/common-js/collections/specialized/CompoundMap'),
	is = require('@barchart/common-js/lang/is');

const DataProvider = require('./../DataProvider');

const PortfolioTable = require('./../../database/tables/PortfolioTable'),
	PositionTable = require('./../../database/tables/PositionTable'),
	TransactionTable = require('./../../database/tables/TransactionTable');

const PositionCalculatorFactory = require('./../../data/calculators/position/PositionCalculatorFactory');

module.exports = (() => {
	'use strict';

	/**
	 * A {@link DataProvider} for portfolio-related operations. Since this object employs in-memory
	 * caching. Consequently, it should be short lived (as prescribed the {@link DataSession} --
	 * which is the most typical consumer).
	 *
	 * @public
	 * @extends {DataProvider}
	 * @param {PortfolioTable} portfolioTable
	 * @param {PositionTable} positionTable
	 * @param {TransactionTable} transactionTable
	 */
	class PortfolioDataProvider extends DataProvider {
		constructor(portfolioTable, positionTable, transactionTable) {
			super();

			assert.argumentIsRequired(portfolioTable, 'portfolioTable', PortfolioTable, 'PortfolioTable');
			assert.argumentIsRequired(positionTable, 'positionTable', PositionTable, 'PositionTable');
			assert.argumentIsRequired(transactionTable, 'transactionTable', TransactionTable, 'TransactionTable');

			this._portfolioTable = portfolioTable;
			this._positionTable = positionTable;
			this._transactionTable = transactionTable;

			this._portfolioPromises = new CompoundMap(1);
			this._positionPromises = new CompoundMap(2);
			this._transactionPromises = new CompoundMap(3);

			this._positionCalculators = new CompoundMap(3);
		}

		getPortfolio(user, portfolio) {
			return this.getPortfolios(user)
				.then((portfolios) => {
					return portfolios.find(p => p.portfolio === portfolio);
				});
		}

		getPortfolios(user) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(user, 'user', String);

					if (!this._portfolioPromises.has(user)) {
						const portfoliosPromise =  this._portfolioTable.getPortfolios(user);

						this._portfolioPromises.put(portfoliosPromise, user);
					}

					return this._portfolioPromises.get(user);
				});
		}

		addPortfolio(portfolio) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(portfolio, 'portfolio', Object);

					const user = portfolio.user;

					return this.getPortfolios(user)
						.then((portfolios) => {
							portfolios.push(portfolio);

							this._portfolioPromises.put(Promise.resolve(portfolios), user);
						});
				});
		}

		savePortfolio(portfolio) {
			return Promise.resolve(portfolio);
		}

		updatePortfolio(portfolio) {
			return Promise.resolve(portfolio);
		}

		getPosition(user, portfolio, position) {
			return this.getPositions(user, portfolio)
				.then((positions) => {
					return positions.find(p => p.user === user && p.position === position);
				});
		}

		getPositions(user, portfolio) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(user, 'user', String);
					assert.argumentIsRequired(portfolio, 'portfolio', String);

					if (!this._positionPromises.has(user, portfolio)) {
						const positionsPromise =  this._positionTable.getPositions(portfolio);

						this._positionPromises.put(positionsPromise, user, portfolio);
					}

					return this._positionPromises.get(user, portfolio);
				});
		}

		addPosition(position) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(position, 'position', Object);

					const user = position.user;
					const portfolio = position.portfolio;
					const instrument = position.instrument;

					return this.getPositions(user, portfolio)
						.then((positions) => {
							const filtered = positions.filter(p => p.instrument.id === instrument.id);

							//if (position.sequence !== filtered.length + 1) {
							//	throw new Error('Unable to add position, the position sequence is out of order.');
							//}

							positions.push(position);

							this._positionPromises.put(Promise.resolve(positions), user, portfolio);
						});
				});
		}

		savePosition(position) {
			return Promise.resolve(position);
		}

		updatePosition(position) {
			return Promise.resolve(position);
		}

		queryPositions(portfolio, schema, limit, descending) {
			return this._positionTable.queryPositions(portfolio, schema, limit, descending);
		}

		getTransaction(user, portfolio, position, sequence) {
			return this.getTransactions(user, portfolio, position)
				.then((transactions) => {
					if (transactions.length < sequence) {
						throw new Error('Transaction is unavailable');
					}

					const transaction = transactions[sequence - 1];

					if (transaction.sequence !== sequence) {
						throw new Error('Transactions are disordered, unable to lookup by sequence');
					}

					return transaction;
				});
		}

		getTransactions(user, portfolio, position) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(user, 'user', String);
					assert.argumentIsRequired(portfolio, 'portfolio', String);
					assert.argumentIsRequired(position, 'position', String);

					if (!this._transactionPromises.has(user, portfolio, position)) {
						const transactionsPromise = this._transactionTable.getTransactions(portfolio, position);

						this._transactionPromises.put(transactionsPromise, user, portfolio, position);
					}

					return this._transactionPromises.get(user, portfolio, position);
				});
		}

		addTransaction(transaction) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(transaction, 'transaction', Object);

					const user = transaction.user;
					const portfolio = transaction.portfolio;
					const position = transaction.position;

					return this.getTransactions(user, portfolio, position)
						.then((transactions) => {
							if (transaction.sequence !== transactions.length + 1) {
								throw new Error('Unable to add transaction, the transaction sequence is out of order.');
							}

							transactions.push(transaction);

							this._transactionPromises.put(Promise.resolve(transactions), user, portfolio, position);
						});
				});
		}

		saveTransaction(transaction) {
			return Promise.resolve(transaction);
		}

		queryTransactionsForPosition(portfolio, position, schema, limit, descending) {
			return this._transactionTable.queryTransactionsForPosition(portfolio, position, schema, limit, descending);
		}

		queryTransactionsForPortfolio(portfolio, start, end, schema, limit, descending) {
			return this._transactionTable.queryTransactionsForPortfolio(portfolio, start, end, schema, limit, descending);
		}

		getPositionCalculator(user, portfolio, position) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(user, 'user', String);
					assert.argumentIsRequired(portfolio, 'portfolio', String);
					assert.argumentIsRequired(position, 'position', String);

					if (!this._positionCalculators.has(user, portfolio, position)) {
						const calculatorPromise = this.getPosition(user, portfolio, position)
							.then((position) => {
								return PositionCalculatorFactory.build(position.valuation, position.instrument.currency, [ ]);
							});

						this._positionCalculators.put(calculatorPromise, user, portfolio, position);
					}

					return this._positionCalculators.get(user, portfolio, position);
				});
		}

		queryPortfoliosForLegacyUser(user) {
			return this._portfolioTable.queryPortfoliosForLegacyUser(user);
		}

		toString() {
			return '[PortfolioDataProvider]';
		}
	}

	return PortfolioDataProvider;
})();
