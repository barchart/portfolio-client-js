const array = require('@barchart/common-js/lang/array'),
	assert = require('@barchart/common-js/lang/assert'),
	Currency = require('@barchart/common-js/lang/Currency'),
	Day = require('@barchart/common-js/lang/Day'),
	Decimal = require('@barchart/common-js/lang/Decimal'),
	is = require('@barchart/common-js/lang/is'),
	object = require('@barchart/common-js/lang/object'),
	Timestamp = require('@barchart/common-js/lang/Timestamp');

const InstrumentType = require('./../../../../data/InstrumentType'),
	PortfolioDataOperation = require('./../../PortfolioDataOperation');

const Recalculate = require('./Recalculate'),
	Save = require('./Save');

module.exports = (() => {
	'use strict';

	/**
	 * Creates a transaction, deferring some details to the inheritor.
	 *
	 * @public
	 * @interface
	 * @extends {PortfolioDataOperation}
	 * @param {Object} data
	 * @param {String} data.user - The identifier of the portfolio's owner.
	 * @param {String} data.portfolio - The identifier of the portfolio.
	 * @param {String=} data.position - The identifier of the position (if omitted, "currency" must be supplied).
	 * @param {Currency=} data.currency - The currency of the cash position (if omitted, "position" must be supplied).
	 * @param {Day} data.date - The day of the transaction.
	 * @param {Timestamp} data.timestamp - The moment of the transaction.
	 */
	class Create extends PortfolioDataOperation {
		constructor(data) {
			super();

			assert.argumentIsRequired(data, 'data', Object);
			assert.argumentIsRequired(data.user, 'data.user', String);
			assert.argumentIsRequired(data.portfolio, 'data.portfolio', String);
			assert.argumentIsRequired(data.date, 'data.date', Day, 'Day');
			assert.argumentIsRequired(data.timestamp, 'data.timestamp', Timestamp, 'Timestamp');

			if (data.position) {
				assert.argumentIsRequired(data.position, 'data.position', String);
			} else {
				assert.argumentIsRequired(data.currency, 'data.currency', Currency, 'Currency');
			}

			this._data = data;
		}

		/**
		 * The {@link TransactionType} which is created by this operation.
		 *
		 * @public
		 * @returns {TransactionType}
		 */
		get type() {
			return null;
		}

		_process(dataProvider) {
			const data = this._data;

			return Promise.resolve({})
				.then((context) => {
					let dataPromise;

					if (data.position) {
						dataPromise = Promise.all([
							dataProvider.getPosition(data.user, data.portfolio, data.position),
							dataProvider.getTransactions(data.user, data.portfolio, data.position)
						]);
					} else if (data.currency) {
						dataPromise = dataProvider.getPositions(data.user, data.portfolio)
							.then((positions) => {
								return positions.find(candidate => candidate.instrument.type === InstrumentType.CASH && candidate.instrument.currency === data.currency);
							}).then((position) => {
								return dataProvider.getTransactions(data.user, data.portfolio, position.position)
									.then((transactions) => {
										return [ position, transactions ];
									});
							});
					} else {
						dataPromise = null;
					}

					return dataPromise.then((results) => {
						context.position = results[0];
						context.transactions = results[1];

						if (!is.object(context.position)) {
							throw new Error('The position does not exist.');
						}

						return context;
					});
				}).then((context) => {
					const data = this._data;

					return Promise.resolve()
						.then(() => {
							return this._createTransaction(context.position, context.transactions, data);
						}).then((transaction) => {
							transaction.type = this.type;

							transaction.user = data.user;
							transaction.portfolio = data.portfolio;
							transaction.position = context.position.position;
							transaction.sequence = context.transactions.length + 1;

							transaction.date = data.date;
							transaction.timestamp = data.timestamp;

							transaction.quantity = transaction.quantity || Decimal.ZERO;
							transaction.amount = transaction.amount || Decimal.ZERO;
							transaction.fee = transaction.fee || Decimal.ZERO;

							if (is.object(data.reference)) {
								transaction.reference = data.reference;
							}

							if (is.object(data.legacy)) {
								transaction.legacy = data.legacy;
							}

							context.transaction = transaction;

							return context;
						});
				}).then((context) => {
					const transaction = context.transaction;

					return dataProvider.addTransaction(transaction)
						.then(() => {
							return context;
						});
				}).then((context) => {
					const transaction = context.transaction;

					this._spawn(new Recalculate(transaction.user, transaction.portfolio, transaction.position, transaction.sequence));
					this._spawn(new Save(transaction.user, transaction.portfolio, transaction.position, transaction.sequence));

					return Promise.resolve()
						.then(() => {
							return this._afterTransactionCreated(context.position, context.transactions, transaction);
						}).then(() => {
							return transaction;
						});
				});
		}

		/**
		 * @protected
		 * @ignore
		 * @param {Position} position
		 * @param {Array.<Transaction>} transactions
		 * @param {Object} data
		 * @returns {Transaction}
		 */
		_createTransaction(position, transactions, data) {
			return data;
		}

		/**
		 * @protected
		 * @ignore
		 * @param {Position} position
		 * @param {Array.<Transaction>} transactions
		 * @param {Transaction} data
		 */
		_afterTransactionCreated(position, transactions, transaction) {
			return;
		}

		toString() {
			return '[Create]';
		}
	}

	return Create;
})();
