const assert = require('@barchart/common-js/lang/assert'),
	Currency = require('@barchart/common-js/lang/Currency'),
	Day = require('@barchart/common-js/lang/Day'),
	Decimal = require('@barchart/common-js/lang/Decimal'),
	is = require('@barchart/common-js/lang/is'),
	object = require('@barchart/common-js/lang/object'),
	Rate = require('@barchart/common-js/lang/Rate'),
	Timestamp = require('@barchart/common-js/lang/Timestamp');

const Credit = require('./Credit'),
	Debit = require('./Debit'),
	InstrumentType = require('./../../../../data/InstrumentType'),
	PortfolioDataOperation = require('./../../PortfolioDataOperation'),
	TransactionType = require('./../../../../data/TransactionType');

module.exports = (() => {
	'use strict';

	/**
	 * Performs a currency exchange (e.g. exchanging 12,000 CAD for 10,000 USD) by
	 * creating two linked transactions -- one {@link TransactionType.CREDIT} transaction
	 * and one {@link TransactionType.DEBIT} transaction.
	 *
	 * @public
	 * @extends {PortfolioDataOperation}
	 * @param {Object} data
	 * @param {String} data.user - The user identifier (of the portfolio's owner).
	 * @param {String} data.portfolio - The identifier of the portfolio.
	 * @param {Day} data.date - The day of the transaction.
	 * @param {Timestamp} data.timestamp - The moment of the transaction.
	 * @param {Object} data.buy
	 * @param {String=} data.buy.position - The position identifier for the currency being purchased (if omitted, "data.buy.currency" must be supplied).
	 * @param {Currency=} data.buy.currency - The currency which is being purchased (if omitted, "data.buy.position" must be supplied).
	 * @param {Decimal=} data.buy.amount - The amount of currency being bought (if omitted, "data.rate" must be supplied).
	 * @param {String=} data.sell.position - The position identifier for the currency being sold (if omitted, "data.sell.currency" must be supplied).
	 * @param {Currency} data.sell.currency - The currency which is being sold (if omitted, "data.sell.position" must be supplied).
	 * @param {Decimal=} data.sell.amount - The amount of currency being sold (if omitted, "data.rate" must be supplied).
	 * @param {Rate=} data.Rate - The exchange rate (if omitted, either "data.buy.amount" or "data.sell.amount" must be supplied).
	 */
	class Exchange extends PortfolioDataOperation {
		constructor(data) {
			super();

			assert.argumentIsRequired(data, 'data', Object);
			assert.argumentIsRequired(data.user, 'data.user', String);
			assert.argumentIsRequired(data.portfolio, 'data.portfolio', String);
			assert.argumentIsRequired(data.date, 'data.date', Day, 'Day');
			assert.argumentIsRequired(data.timestamp, 'data.timestamp', Timestamp, 'Timestamp');

			assert.argumentIsRequired(data.buy, 'data.buy');
			assert.argumentIsRequired(data.sell, 'data.sell');

			if (data.buy.position) {
				assert.argumentIsRequired(data.buy.position, 'data.buy.position', String);
			} else {
				assert.argumentIsRequired(data.buy.currency, 'data.buy.currency', Currency, 'Currency');
			}

			if (data.buy.amount) {
				assert.argumentIsRequired(data.buy.amount, 'data.buy.amount', Decimal, 'Decimal');
			} else {
				assert.argumentIsRequired(data.sell.amount, 'data.sell.amount', Decimal, 'Decimal');
				assert.argumentIsRequired(data.rate, 'data.rate', Rate, 'Rate');
			}

			if (data.sell.position) {
				assert.argumentIsRequired(data.sell.position, 'data.sell.position', String);
			} else {
				assert.argumentIsRequired(data.sell.currency, 'data.sell.currency', Currency, 'Currency');
			}

			if (data.sell.amount) {
				assert.argumentIsRequired(data.sell.amount, 'data.sell.amount', Decimal, 'Decimal');
			} else {
				assert.argumentIsRequired(data.buy.amount, 'data.buy.amount', Decimal, 'Decimal');
				assert.argumentIsRequired(data.rate, 'data.rate', Rate, 'Rate');
			}

			this._data = data;
		}

		_process(dataProvider) {
			return Promise.resolve()
				.then(() => {
					const data = this._data;

					return Promise.all([
						getPositionPromise(dataProvider, data.user, data.portfolio, data.buy.position, data.buy.currency),
						getPositionPromise(dataProvider, data.user, data.portfolio, data.sell.position, data.sell.currency)
					]).then((positions) => {
						const buyPosition = positions[0];
						const sellPosition = positions[1];

						const buyCurrency = buyPosition.instrument.currency;
						const sellCurrency = sellPosition.instrument.currency;

						let bought;
						let sold;

						if (data.buy.amount && data.sell.amount) {
							bought = data.buy.amount;
							sold = data.sell.amount;
						} else if (data.buy.amount) {
							bought = Rate.convert(data.buy.amount, buyCurrency, sellCurrency, data.rate).round(sellCurrency.precision);
							sold = data.buy.amount;
						} else {
							bought = data.sell.amount;
							sold = Rate.convert(data.sell.amount, sellCurrency, buyCurrency, data.rate).round(buyCurrency.precision);
						}

						let buyDescription = `Receive ${bought.toFixed()} ${buyCurrency.code} (for ${sold.toFixed()} ${sellCurrency.code})`;
						let sellDescription = `Pay ${sold.toFixed()} ${sellCurrency.code} (for ${bought.toFixed()} ${buyCurrency.code})`;

						this._spawn(new Credit(getTransactionData(data, buyPosition.position, bought, buyDescription)));
						this._spawn(new Debit(getTransactionData(data, sellPosition.position, sold.opposite(), sellDescription)));
					});
				});
		}

		toString() {
			return '[Exchange]';
		}
	}

	function getPositionPromise(dataProvider, user, portfolio, position, currency) {
		let returnRef;

		if (position) {
			returnRef = dataProvider.getPosition(user, portfolio, position);
		} else {
			returnRef = dataProvider.getPositions(user, portfolio)
				.then((positions) => {
					return positions.find(candidate => candidate.instrument.type === InstrumentType.CASH && candidate.instrument.currency === currency);
				});
		}

		return returnRef;
	}

	function getTransactionData(data, position, amount, description) {
		const returnRef = { };

		returnRef.user = data.user;
		returnRef.portfolio = data.portfolio;
		returnRef.date = data.date;
		returnRef.timestamp = data.timestamp;
		returnRef.position = position;
		returnRef.amount = amount;
		returnRef.description = description;

		if (is.object(data.legacy)) {
			returnRef.legacy = object.clone(data.legacy);
		}

		return returnRef;
	}

	return Exchange;
})();
