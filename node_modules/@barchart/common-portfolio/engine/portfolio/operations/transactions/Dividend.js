const assert = require('@barchart/common-js/lang/assert'),
	attributes = require('@barchart/common-js/lang/attributes'),
	Day = require('@barchart/common-js/lang/Day'),
	Decimal = require('@barchart/common-js/lang/Decimal'),
	is = require('@barchart/common-js/lang/is');

const Create = require('./Create'),
	Credit = require('./Credit'),
	Debit = require('./Debit'),
	TransactionType = require('./../../../../data/TransactionType');

module.exports = (() => {
	'use strict';

	/**
	 * Creates a {@link TransactionType.DIVIDEND} transaction.
	 *
	 * @public
	 * @extends {Create}
	 * @param {Object} data
	 * @param {String} data.user - The user identifier (of the portfolio's owner).
	 * @param {String} data.portfolio - The identifier of the portfolio.
	 * @param {String} data.position - The identifier of the position.
	 * @param {Day} data.date - The day of the transaction.
	 * @param {Timestamp} data.timestamp - The moment of the transaction.
	 * @param {Decimal} data.rate - The per-unit amount to be paid in dividends.
	 * @param {Decimal=} data.open - The number of shares held at the time the dividend payment is calculated (overrides the position as of the "effective" date).
	 * @param {Day=} data.effective - The ex-dividend date (i.e. the date the dividend payment is calculated).
	 */
	class Dividend extends Create {
		constructor(data) {
			super(data);

			assert.argumentIsValid(data.rate, 'data.rate', Decimal.getIsNotNegative, 'cannot be negative');

			if (data.open) {
				assert.argumentIsRequired(data.open, 'data.open', Decimal, 'Decimal');
			}

			assert.argumentIsOptional(data.effective, 'data.effective', Day, 'Day');
		}

		get type() {
			return TransactionType.DIVIDEND;
		}

		_createTransaction(position, transactions, data) {
			let open;

			if (data.open) {
				open = data.open;
			} else {
				open = getOpenPositionOn(data.effective, transactions);
			}

			const dividend = { };

			dividend.rate = data.rate;
			dividend.amount = open.multiply(data.rate).round(position.instrument.currency.precision, Decimal.ROUNDING_MODE.DOWN);

			if (data.effective) {
				dividend.effective = data.effective;
			}

			return {
				dividend: dividend
			};
		}

		_afterTransactionCreated(position, transactions, transaction) {
			const data = { };

			data.user = transaction.user;
			data.portfolio = transaction.portfolio;
			data.currency = position.instrument.currency;

			data.date = transaction.date;
			data.timestamp = transaction.timestamp;

			data.amount = transaction.dividend.amount;

			data.reference = {
				position: transaction.position,
				sequence: transaction.sequence
			};

			data.description = `Dividend on ${getDescriptionForInstrument(position.instrument)}`;

			if (is.object(transaction.legacy)) {
				const legacy = { };

				if (transaction.legacy.system) {
					legacy.system = transaction.legacy.system;
				}

				if (transaction.legacy.user) {
					legacy.user = transaction.legacy.user;
				}

				if (transaction.legacy.portfolio) {
					legacy.portfolio = transaction.legacy.portfolio;
				}

				data.legacy = legacy;
			}

			let operation;

			if (data.amount.getIsNegative()) {
				operation = new Debit(data);
			} else {
				operation = new Credit(data);
			}

			this._spawn(operation);
		}

		toString() {
			return '[Dividend]';
		}
	}

	function getOpenPositionOn(date, transactions) {
		return transactions.reduce((current, transaction) => {
			if (transaction.date.getIsAfter(date)) {
				return current;
			} else {
				return transaction.snapshot.open;
			}
		}, Decimal.ZERO);
	}

	function getDescriptionForInstrument(instrument) {
		if (attributes.has(instrument, 'symbol.display')) {
			return attributes.read(instrument, 'symbol.display');
		} else {
			return instrument.name || instrument.id;
		}
	}

	return Dividend;
})();
