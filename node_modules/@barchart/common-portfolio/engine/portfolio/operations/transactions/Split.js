const assert = require('@barchart/common-js/lang/assert'),
	Day = require('@barchart/common-js/lang/Day'),
	Decimal = require('@barchart/common-js/lang/Decimal');

const Create = require('./Create'),
	TransactionType = require('./../../../../data/TransactionType');

module.exports = (() => {
	'use strict';

	/**
	 * Creates a {@link TransactionType.SPLIT} transaction.
	 *
	 * @public
	 * @extends {Create}
	 * @param {Object} data
	 * @param {String} data.user - The user identifier (of the portfolio's owner).
	 * @param {String} data.portfolio - The identifier of the portfolio.
	 * @param {String} data.position - The identifier of the position.
	 * @param {Day} data.date - The day of the transaction.
	 * @param {Timestamp} data.timestamp - The moment of the transaction.
	 * @param {Decimal} data.numerator - The number of shares received (e.g. 3 in the cash of a 3-for-2 split; or, 2 in the case of a 2-for-3 reverse split).
	 * @param {Decimal} data.denominator - The number of shares given (e.g. 2 in the cash of a 3-for-2 split; or, 3 in the case of a 2-for-3 reverse split).
	 * @param {Decimal=} data.open - The number of shares held at the time the split is calculated (overrides the position as of the "effective" date).
	 * @param {Day=} data.effective - The date of the split (used to determine position at the time of the split).
	 */
	class Split extends Create {
		constructor(data) {
			super(data);

			assert.argumentIsValid(data.numerator, 'data.numerator', Decimal.getIsNotZero, 'cannot be zero');
			assert.argumentIsValid(data.denominator, 'data.denominator', Decimal.getIsNotZero, 'cannot be zero');

			if (data.numerator.getIsPositive() !== data.denominator.getIsPositive()) {
				throw new Error('The numerator and denominator must share the same sign');
			}

			if (data.open) {
				assert.argumentIsRequired(data.open, 'data.open', Decimal, 'Decimal');
			}

			assert.argumentIsOptional(data.effective, 'data.effective', Day, 'Day');
		}

		get type() {
			return TransactionType.SPLIT;
		}

		_createTransaction(position, transactions, data) {
			let open;

			if (data.open) {
				open = data.open;
			} else {
				open = getOpenPositionOn(data.effective, transactions);
			}

			const desired = open.multiply(data.numerator).divide(data.denominator);
			const delta = desired.subtract(open);

			const split = { };

			split.numerator = data.numerator;
			split.denominator = data.denominator;

			if (data.effective) {
				split.effective = data.effective;
			}

			return {
				quantity: delta,
				split: split
			};
		}

		toString() {
			return '[Split]';
		}
	}

	function getOpenPositionOn(date, transactions) {
		return transactions.reduce((current, transaction) => {
			if (transaction.date.getIsAfter(date)) {
				return current;
			} else {
				return transaction.snapshot.open;
			}
		}, Decimal.ZERO);
	}

	return Split;
})();