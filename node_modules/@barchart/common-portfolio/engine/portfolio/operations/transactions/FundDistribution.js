const assert = require('@barchart/common-js/lang/assert'),
	Day = require('@barchart/common-js/lang/Day'),
	Decimal = require('@barchart/common-js/lang/Decimal');

const Create = require('./Create'),
	TransactionType = require('./../../../../data/TransactionType');

module.exports = (() => {
	'use strict';

	/**
	 * Creates a {@link TransactionType.DISTRIBUTION_FUND} transaction.
	 *
	 * @public
	 * @extends {Create}
	 * @param {Object} data
	 * @param {String} data.user - The user identifier (of the portfolio's owner).
	 * @param {String} data.portfolio - The identifier of the portfolio.
	 * @param {String} data.position - The identifier of the position.
	 * @param {Day} data.date - The day of the transaction.
	 * @param {Timestamp} data.timestamp - The moment of the transaction.
	 * @param {Decimal} data.rate - The per-unit amount to be converted into new units.
	 * @param {Decimal} data.price - The net asset value to use for the conversion to new units.
	 * @param {Decimal=} data.open - The number of units held at the time the payment is calculated (overrides the position as of the "effective" date).
	 * @param {Day=} data.effective - The day on which the number of units held is determined (similar to ex-dividend date for stocks).
	 * @param {Decimal=} data.override - The number of units distributed (if present, units distributed is *not* calculated).
	 */
	class FundDistribution extends Create {
		constructor(data) {
			super(data);

			if (data.override) {
				assert.argumentIsRequired(data.override, 'data.override', Decimal, 'Decimal');
			} else {
				assert.argumentIsValid(data.rate, 'data.rate', Decimal.getIsNotNegative, 'cannot be negative');
				assert.argumentIsValid(data.price, 'data.price', Decimal.getIsNotNegative, 'cannot be negative');

				if (data.open) {
					assert.argumentIsValid(data.open, 'data.open', Decimal.getIsNotNegative, 'cannot be negative');
				}
			}

			assert.argumentIsOptional(data.effective, 'data.effective', Day, 'Day');
		}

		get type() {
			return TransactionType.DISTRIBUTION_FUND;
		}

		_createTransaction(position, transactions, data) {
			let quantity;
			let dividend;

			if (data.override) {
				quantity = data.override;
				dividend = null;
			} else {
				let open;

				if (data.open) {
					open = data.open;
				} else {
					open = getOpenPositionOn(data.effective, transactions);
				}

				const quantity = open.multiply(data.rate).divide(data.price);

				dividend = { };

				dividend.rate = data.rate;
				dividend.price = data.price;

				if (data.effective) {
					dividend.effective = data.effective;
				}
			}

			const transaction = {
				quantity: quantity
			};

			if (dividend) {
				transaction.dividend = dividend;
			}

			return transaction;
		}

		toString() {
			return '[FundDistribution]';
		}
	}

	function getOpenPositionOn(date, transactions) {
		return transactions.reduce((current, transaction) => {
			if (transaction.date.getIsAfter(date)) {
				return current;
			} else {
				return transaction.snapshot.open;
			}
		}, Decimal.ZERO);
	}

	return FundDistribution;
})();