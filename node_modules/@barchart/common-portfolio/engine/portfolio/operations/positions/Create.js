const assert = require('@barchart/common-js/lang/assert'),
	Currency = require('@barchart/common-js/lang/Currency'),
	is = require('@barchart/common-js/lang/is');

const PortfolioDataOperation = require('./../../PortfolioDataOperation'),
	ValuationType = require('./../../../../data/ValuationType');

const Save = require('./Save');

module.exports = (() => {
	'use strict';

	/**
	 * Opens a new {@link Position}.
	 *
	 * @public
	 * @extends {PortfolioDataOperation}
	 * @param {Object} data
	 * @param {String} data.user - The identifier of the portfolio's owner.
	 * @param {String} data.portfolio - The identifier of the portfolio.
	 * @param {Number} data.sequence - The position sequence number (must be unique for each portfolio/instrument combination).
	 * @param (Instrument} data.instrument
	 * @param {ValuationType=} valuation - The valuation strategy used for the position.
	 * @param {Boolean=} reinvest - Indicates if dividends, distributions, or income are re-invested into the position.
	 */
	class Create extends PortfolioDataOperation {
		constructor(data) {
			super();

			assert.argumentIsRequired(data.user, 'data.user', String);
			assert.argumentIsRequired(data.portfolio, 'data.portfolio', String);
			assert.argumentIsRequired(data.sequence, 'data.sequence', Number);

			assert.argumentIsRequired(data.instrument, 'data.instrument', Object);
			assert.argumentIsRequired(data.instrument.id, 'data.instrument.id', String);
			assert.argumentIsRequired(data.instrument.name, 'data.instrument.name', String);
			assert.argumentIsRequired(data.instrument.currency, 'data.instrument.currency', Currency, 'Currency');

			if (is.object(data.instrument.symbol)) {
				assert.argumentIsOptional(data.instrument.symbol.display, 'data.instrument.symbol.display', String);
				assert.argumentIsOptional(data.instrument.symbol.barchart, 'data.instrument.symbol.barchart', String);
			}

			assert.argumentIsOptional(data.valuation, 'data.valuation', ValuationType, 'ValuationType');
			assert.argumentIsOptional(data.valuation, 'data.reinvest', Boolean);

			if (is.object(data.legacy)) {
				assert.argumentIsOptional(data.legacy.system, 'data.legacy.system', String);
				assert.argumentIsOptional(data.legacy.user, 'data.legacy.user', String);
				assert.argumentIsOptional(data.legacy.portfolio, 'data.legacy.portfolio', String);
				assert.argumentIsOptional(data.legacy.position, 'data.legacy.position', String);
			}

			this._data = data;
		}

		_process(dataProvider) {
			const data = this._data;

			return dataProvider.getPortfolio(data.user, data.portfolio)
				.then((portfolio) => {
					if (!is.object(portfolio)) {
						throw new Error('Portfolio does not exist');
					}

					const position = { };

					position.user = data.user;
					position.portfolio = data.portfolio;
					position.position = `${data.instrument.id}-${data.sequence}`;
					position.sequence = data.sequence;
					position.instrument = data.instrument;
					position.valuation = data.valuation || portfolio.defaults.valuation;
					position.reinvest = data.reinvest || portfolio.defaults.reinvest;
					position.transaction = 0;

					if (is.object(data.legacy)) {
						position.legacy = data.legacy;
					}

					return dataProvider.addPosition(position)
						.then(() => {
							this._spawn(new Save(position.user, position.portfolio, position.position));

							return position;
						});
				});
		}

		toString() {
			return '[Create]';
		}
	}

	return Create;
})();
