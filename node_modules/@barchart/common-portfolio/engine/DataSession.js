const log4js = require('log4js');

const assert = require('@barchart/common-js/lang/assert'),
	array = require('@barchart/common-js/lang/array'),
	PriorityQueue = require('@barchart/common-js/collections/specialized/PriorityQueue'),
	promise = require('@barchart/common-js/lang/promise');

const DataProvider = require('./DataProvider'),
	DataOperation = require('./DataOperation'),
	DataOperationResult = require('./DataOperationResult');

module.exports = (() => {
	'use strict';

	const logger = log4js.getLogger('portfolio-common/engine/DataSession');

	let instance = 0;

	/**
	 * The manager for {@link DataOperation} execution. This should be a very short-lived
	 * object -- quickly adding operations, then flushing, then discarding.
	 *
	 * @public
	 * @param {Function} comparator - The comparator used to sort {@link DataOperation} instances in a {@link PriorityQueue}.
	 */
	class DataSession {
		constructor(comparator) {
			this._instance = ++instance;
			this._enqueueCounter = 0;

			this._pending = new PriorityQueue(comparator);
			this._processed = [ ];

			this._flushed = false;
		}

		/**
		 * Adds a new {@link DataOperation} and returns the current instance.
		 *
		 * @public
		 * @param {@DataOperation} operation
		 * @returns {DataSession}
		 */
		withOperation(operation) {
			assert.argumentIsRequired(operation, 'operation', DataOperation, 'DataOperation');

			if (this._flushed) {
				throw new Error('Unable to add operation to session, it has been flushed.');
			}

			enqueue.call(this, operation);

			return this;
		}

		/**
		 * Processes all the {@link DataOperation} instances held within the session.
		 *
		 * @public
		 * @param {DataProvider} dataProvider
		 * @returns {Promise}
		 */
		flush(dataProvider) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired(dataProvider, 'dataProvider', DataProvider, 'DataProvider');

					if (this._flushed) {
						throw new Error('Session [', this._instance, '] has already been flushed.');
					}

					this._flushed = true;

					logger.debug('Session [', this._instance, '] flush starting.');

					if (this._pending.empty()) {
						logger.warn('Session [', this._instance, '] has no operations.');
					}

					let userEnqueuedCount = this._enqueueCounter;
					let operationCounter = 0;

					const output = [ ];

					const flushRecursive = (previousResult) => {
						return Promise.resolve()
							.then(() => {
								let processPromise;

								if (this._pending.empty()) {
									processPromise = Promise.resolve(previousResult);
								} else {
									let operation = null;
									let operationCount;

									while (operation === null && !this._pending.empty()) {
										const candidate = this._pending.dequeue();

										operationCount = ++operationCounter;

										if (candidate.equals(previousResult.operation)) {
											logger.debug('Session [', this._instance, '] operation [', operationCount, '][', candidate.toString() ,'] discarded as duplicate.');
										} else {
											operation = candidate;
										}
									}

									if (operation === null) {
										processPromise = Promise.resolve(previousResult);
									} else {
										this._processed.push(operation);

										logger.debug('Session [', this._instance, '] operation [', operationCount, '][', operation.toString() ,'] starting.');

										processPromise = operation.process(dataProvider)
											.then((result) => {
												logger.debug('Session [', this._instance, '] operation [', operationCount, '][', operation.toString() ,'] complete.');

												if (!(operation.enqueueOrder > userEnqueuedCount)) {
													const outputIndex = operation.enqueueOrder - 1;

													output[outputIndex] = result.result;
												}

												result.children.forEach(operation => enqueue.call(this, operation));

												return result;
											});
									}

									processPromise = processPromise.then((result) => {
										return flushRecursive(result);
									});
								}

								return processPromise;
							});
					};

					return flushRecursive(DataOperationResult.getInitial())
						.then((result) => {
							logger.debug('Session [', this._instance, '] flush completed.');

							if (output.length === 1) {
								return output[0];
							} else {
								return output;
							}
						});
				});
		}

		toString() {
			return '[DataSession]';
		}
	}

	function enqueue(operation) {
		operation.enqueueOrder = ++this._enqueueCounter;

		this._pending.enqueue(operation);
	}

	return DataSession;
})();
