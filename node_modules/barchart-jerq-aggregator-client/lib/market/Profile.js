const utilities = require('barchart-marketdata-utilities');

const assert = require('common/lang/assert'),
	is = require('common/lang/is'),
	memoize = require('common/lang/memoize'),
	timezone = require('common/lang/timezone');

const dates = require('./../utilities/dates'),
	Quote = require('./Quote');

module.exports = (() => {
	'use strict';

	const priceFormatter = utilities.priceFormatter('-', false, ',').format;
	const priceFormatterSpecial = utilities.priceFormatter('-', true, ',').format;

	const volumeFormatter = (value) => {
		return utilities.decimalFormatter(value, 0, ',');
	};

	const getTimezoneNameForSymbol = (symbol) => {
		if (utilities.symbolParser.getIsFuture(symbol) || utilities.symbolParser.getIsForex(symbol)) {
			return 'America/Chicago';
		} else {
			return 'America/New_York';
		}
	};

	const resolveTimezoneName = memoize.simple((timezoneName) => {
		if (is.string(timezoneName) && timezone.hasTimezone(timezoneName)) {
			return timezoneName;
		} else {
			return null;
		}
	});

	/**
	 * <p>
	 *     The metadata which describes an instrument.
	 * <p>
	 * <p>
	 *     The instance for a specific instrument can be obtained from the
	 *     {@link MarketState#getProfile} function; however, the instance
	 *     will not be initialized until a subscription has been established
	 *     (see {@link Connection#on}).
	 * </p>
	 * <p>
	 *     Instances are mutable; however, the {@link Connection} is responsible
	 *     for processing the market data feed from the server and updating these
	 *     instances. Consequently, consumers should not make modifications.
	 * <p>
	 *
	 * @public
	 */
	class Profile {
		constructor(symbol, name, exchange, unitCode, pointValue, tickIncrement, root, month, year) {
			assert.argumentIsRequired(symbol, 'symbol', String);

			/**
			 * @property {string} symbol - the instrument's symbol
			 */
			this.symbol = utilities.symbolFormatter.format(symbol);

			/**
			 * @property {string} name - the instrument's name
			 */
			this.name = name || null;

			/**
			 * @property {string} exchange - the code for the listing exchange
			 */
			this.exchange = exchange || null;

			/**
			 * @property {string} unitCode - code used to describe how a price should be formatted
			 */
			this.unitCode = unitCode || null;

			/**
			 * @property {string} pointValue - the change in dollar value for a one point change in price
			 */
			this.pointValue = pointValue || null;

			/**
			 * @property {number} tickIncrement - the minimum price movement
			 */
			this.tickIncrement = tickIncrement || null;


			this.displayUsingPercent = utilities.symbolParser.displayUsingPercent(symbol);

			/**
			 * @property {undefined|string} root - he root symbol, if a future; otherwise undefined
			 */
			this.root = root || null;

			/**
			 * @property {undefined|string} month - the month code, if a future; otherwise undefined
			 */
			this.month = month || null;

			/**
			 * @property {undefined|number} year - the expiration year, if a symbol; otherwise undefined
			 */
			this.year = year || null;

			let timezoneName  = getTimezoneNameForSymbol(symbol);

			/**
			 * <See the [formatDate]{@link Profile#formatDate}, [formatTime]{@link Profile#formatQuote}, and [formatQuoteTime]{@link Profile#formatQuoteTime} instance functions.
			 *
			 * @property {string} timezoneName - the timezone used to output human-readable dates and time
			 * @name Profile#timezoneName
			 */
			Object.defineProperty(this, 'timezoneName', {
				get: () => {
					return timezoneName;
				},
				set: (value) => {
					if (value !== resolveTimezoneName(value)) {
						throw new Error('Unable to set invalid timezone.');
					}

					timezoneName = value || getTimezoneNameForSymbol(this.symbol);
				},
				enumerable: true
			});
		}

		/**
		 * Indicates if the object's data has been populated from the server.
		 * 
		 * @returns {*}
		 */
		getIsInitialized() {
			return is.string(this.name);
		}

		/**
		 * Generates a human-readable price, in the format appropriate for this
		 * instrument (i.e. using decimal, percent, or dash notation; with the 
		 * correct level of precision).
		 * 
		 * @param {number=} value - The price to format.
		 * @param {Boolean=} includeSign - If true, a plus sign will be prepended to positive values.
		 * @returns {null|string}
		 */
		formatPrice(value, includeSign) {
			let returnRef;

			if (is.number(value) && this.unitCode !== null) {
				if (this.displayUsingPercent) {
					returnRef = this.formatPercent(value, includeSign);
				} else {
					if (is.string(this.root)) {
						returnRef = priceFormatterSpecial(value, this.unitCode);
					} else {
						returnRef = priceFormatter(value, this.unitCode);
					}

					if (includeSign && !(value < 0)) {
						returnRef = '+' + returnRef;
					}
				}
			} else {
				returnRef = null;
			}

			return returnRef;
		}

		/**
		 * Generates a human-readable value that represents a settlement price. For futures, 
		 * the letter "s" is appened to the price; with that exception, this function is identical 
		 * to {@link Profile#formatPrice}.
		 *
		 * @param {number=} value - The price to format.
		 * @param {Boolean=} includeSign - If true, a plus sign will be prepended to positive values.
		 * @returns {null|string}
		 */
		formatPriceForSettlement(value, includeSign) {
			let returnRef = this.formatPrice(value, includeSign);

			if (returnRef && is.string(this.root)) {
				returnRef = returnRef + 's';
			}

			return returnRef;
		}

		/**
		 * Generates a human-readable value that represents a change in price. If the
		 * price change is zero; the value "unch" will be returned; with that exception,
		 * this function is identical to {@link Profile#formatPrice}.
		 *
		 * @param {number=} value - The price change amount to format.
		 * @param {Boolean=} includeSign - If true, a plus sign will be prepended to positive values.
		 * @returns {null|string}
		 */
		formatPriceChange(value, includeSign) {
			let returnRef;

			if (is.number(value)) {
				if (value === 0) {
					returnRef = 'unch';
				} else {
					returnRef = this.formatPrice(value, includeSign);
				}
			} else {
				returnRef = null;
			}

			return returnRef;
		}

		/**
		 * Formats a number as a percent, with two decimal places, and appending
		 * the percent sign.
		 *
		 * @param {number=} value - The value to format.
		 * @param {Boolean=} includeSign - If true, a plus sign will be prepended to positive values.
		 * @returns {null|string}
		 */
		formatPercent(value, includeSign) {
			let returnRef;

			if (is.number(value)) {
				returnRef = (value * 100).toFixed(2) + '%';

				if (includeSign && !(value < 0)) {
					returnRef = '+' + returnRef;
				}
			} else {
				returnRef = null;
			}

			return returnRef;
		}

		/**
		 * Generates a human-readable value that represents a change in percent. If the
		 * price change is zero; the value "unch" will be returned; with that exception,
		 * this function is identical to {@link Profile#formatPercent}.
		 *
		 * @param {number=} value - The value to format.
		 * @param {Boolean=} includeSign - If true, a plus sign will be prepended to positive values.
		 * @returns {null|string}
		 */
		formatPercentChange(value, includeSign) {
			let returnRef;

			if (is.number(value)) {
				if (value === 0) {
					returnRef = 'unch';
				} else {
					returnRef = this.formatPercent(value, includeSign);
				}
			} else {
				returnRef = null;
			}

			return returnRef;
		}

		/**
		 * Generates a human-readable value for volume.
		 *
		 * @param {number=} value - The value to format.
		 * @param {number=} divisor - If provided, this value will be used to divide the value to format.
		 * @returns {null|string}
		 */
		formatVolume(value, divisor) {
			let valueToFormat;

			if (is.number(value) && is.number(divisor) && divisor > 0) {
				valueToFormat = value / divisor;
			} else {
				valueToFormat = value;
			}

			return volumeFormatter(valueToFormat);
		}

		/**
		 * Given a {@link Quote} object, outputs the appropriate human-readable
		 * timestamp. Depending on the state of the quote, the output may be a
		 * time (e.g. "09:31 CT") or a date (e.g. "06/28/2017").
		 *
		 * @public
		 * @param {Quote} quote - The {@link Quote} instance to generate a human-readable timestamp for.
		 * @param {string=} timezoneName - If provided (and valid), the timestamp will be displayed in this timezone; otherwise the default timezone for the instance is used.
		 * @returns {string}
		 */
		formatQuoteTime(quote, timezoneName) {
			return dates.formatQuoteTime(quote, resolveTimezoneName(timezoneName) || this.timezoneName);
		}

		/**
		 * Generates a timezone-specific, human-readable date from a timestamp (e.g. "06/28/2017").
		 *
		 * @public
		 * @param {Date|number} value - The timestamp to format.
		 * @param {string=} timezoneName - If provided (and valid), the timestamp will be displayed in this timezone; otherwise the default timezone for the instance is used.
		 * @returns {string}
		 */
		formatDate(value, timezoneName) {
			return dates.formatDate(value, resolveTimezoneName(timezoneName) || this.timezoneName);
		}

		/**
		 * Generates a timezone-specific, human-readable time from a timestamp (e.g. "09:31 CT").
		 *
		 * @public
		 * @param {Date|number} value - The timestamp to format.
		 * @param {string=} timezoneName - If provided (and valid), the timestamp will be displayed in this timezone; otherwise the default timezone for the instance is used.
		 * @returns {string}
		 */
		formatTime(value, timezoneName) {
			return dates.formatTime(value, resolveTimezoneName(timezoneName) || this.timezoneName);
		}

		toString() {
			return `[Profile (description: ${this.symbol})]`;
		}
	}

	return Profile;
})();

