const utilities = require('barchart-marketdata-utilities');

const assert = require('common/lang/assert'),
	dateUtilities = require('common/lang/date'),
	is = require('common/lang/is');

module.exports = (() => {
	'use strict';

	/**
	 * <p>
	 *     Current market conditions for an instrument.
	 * <p>
	 * <p>
	 *     The instance for a specific instrument can be obtained from the
	 *     {@link MarketState#getQuote} function; however, the instance
	 *     will not be initialized (or reflect the current conditions) until
	 *     a subscription has been established (see {@link Connection#on}).
	 * </p>
	 * <p>
	 *     Instances are mutable; however, the {@link Connection} is responsible
	 *     for processing the market data feed from the server and updating these
	 *     instances. Consequently, consumers should not make modifications.
	 * <p>
	 *
	 * @public
	 * @param {string} symbol - The instrument's symbol.
	 */
	class Quote {
		constructor(symbol) {
			assert.argumentIsRequired(symbol, 'symbol', String);

			/**
			 * @property {string} symbol - The instrument's symbol.
			 */
			this.symbol = utilities.symbolFormatter.format(symbol);


			this.online = false;
			this.active = true;
			this.sequence = 0;

			this.mode = null;
			this.dayNum = 0;
			this.bidPrice = null;
			this.bidSize = null;
			this.askPrice = null;
			this.askSize = null;
			this.tradePrice = null;
			this.tradeSize = null;
			this.numberOfTrades = null;
			this.vwap1 = null;
			this.openPrice = null;
			this.volume = null;
			this.openInterest = null;

			this.priceChange = null;
			this.percentChange = null;
			this.lastPriceDirection = null;

			this.time = null;
			this.timeActual = null;
			this.timeDisplay = null;

			this.timeDateDisplayLong = null;
			this.sessionDateDisplayLong = null;
			this.previousTimeDateDisplayLong = null;

			this.tradeTime = null;
			this.tradeTimeActual = null;
			this.tradeTimeDisplay = null;
			this.tradeDateDisplay = null;

			this.previousOpenPrice = null;
			this.previousHighPrice = null;
			this.previousLowPrice = null;

			this.lastPriceHigh = null;
			this.lastPriceLow = null;

			this.premarketPriceChange = null;
			this.premarketPercentChange = null;

			this.postmarketPriceChange = null;
			this.postmarketPercentChange = null;

			this.previousPriceChange = null;
			this.previousPercentChange = null;

			let day = null;

			let flag = null;
			let state = null;

			let session = null;
			let sessionT = null;

			let todayPrice = null;
			let previousPrice = null;
			let settlementPrice = null;

			let lastPrice = null;
			let lastPriceT = null;

			let premarketPrice = null;
			let postmarketPrice = null;

			let highPrice = null;
			let lowPrice = null;

			let previousPreviousPrice = null;
			let previousSettlementPrice = null;

			let priceVol = null;

			let timeDateDisplay = null;
			let sessionDateDisplay = null;
			let previousTimeDateDisplay = null;

			Object.defineProperty(this, 'day', {
				get: () => {
					return day;
				},
				set: (value) => {
					if (day !== value) {
						day = value;

						this.lastPriceHigh = null;
						this.lastPriceLow = null;
					}
				},
				enumerable: true
			});

			/**
			 * @property {string} flag - Current market status, will have one of three values: p, s, or undefined
			 * @name Quote#flag
			 */
			Object.defineProperty(this, 'flag', {
				get: () => {
					return flag;
				},
				set: (value) => {
					if (flag !== value) {
						flag = value;

						calculateState(this);
						calculateActiveStatus(this);
						calculateTodayPrice(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'state', {
				get: () => {
					return state;
				},
				set: (value) => {
					if (state !== value) {
						state = value;

						calculatePriceChangeForPremarket(this);
						calculatePriceChangeForPostmarket(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'session', {
				get: () => {
					return session;
				},
				set: (value) => {
					if (session !== value) {
						session = value;

						calculateActiveStatus(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'sessionT', {
				get: () => {
					return sessionT;
				},
				set: (value) => {
					if (sessionT !== value) {
						sessionT = value;

						calculateState(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'todayPrice', {
				get: () => {
					return todayPrice;
				},
				set: (value) => {
					if (todayPrice !== value) {
						todayPrice = value;

						calculatePriceChangeForToday(this);
						calculatePriceChangeForPostmarket(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'previousPrice', {
				get: () => {
					return previousPrice;
				},
				set: (value) => {
					if (previousPrice !== value) {
						previousPrice = value;

						calculatePriceChangeForToday(this);
						calculatePriceChangeForPremarket(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'settlementPrice', {
				get: () => {
					return settlementPrice;
				},
				set: (value) => {
					if (settlementPrice !== value) {
						settlementPrice = value;

						calculateTodayPrice(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'premarketPrice', {
				get: () => {
					let returnVal;

					if (state === 'p') {
						returnVal = premarketPrice;
					} else {
						returnVal = null;
					}

					return returnVal;
				},
				set: (value) => {
					premarketPrice = value;
				},
				enumerable: true
			});

			Object.defineProperty(this, 'postmarketPrice', {
				get: () => {
					let returnVal;

					if (state === 's') {
						returnVal = postmarketPrice;
					} else {
						returnVal = null;
					}

					return returnVal;
				},
				set: (value) => {
					postmarketPrice = value;
				},
				enumerable: true
			});

			Object.defineProperty(this, 'lastPrice', {
				get: () => {
					return lastPrice;
				},
				set: (value) => {
					if (lastPrice !== null && value !== null) {
						let direction;

						if (lastPrice > value) {
							direction = 'down';
						} else if (lastPrice < value) {
							direction = 'up';
						} else {
							direction = 'unchanged';
						}

						this.lastPriceDirection = direction;
					}

					if (lastPrice !== value) {
						lastPrice = value;

						calculateTodayPrice(this);
						calculatePriceVol(this);

						if (is.number(lastPrice)) {
							if (!is.number(this.lastPriceHigh) || lastPrice > this.lastPriceHigh) {
								this.lastPriceHigh = lastPrice;
							}

							if (!is.number(this.lastPriceLow) || lastPrice < this.lastPriceLow) {
								this.lastPriceLow = lastPrice;
							}
						}
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'lastPriceT',  {
				get: () => {
					return lastPriceT;
				},
				set: (value) => {
					if (lastPriceT !== value) {
						lastPriceT = value;

						this.premarketPrice = value;
						this.postmarketPrice = value;

						calculatePriceChangeForPremarket(this);
						calculatePriceChangeForPostmarket(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'highPrice', {
				get: () => {
					let derivedPrice = Math.max(highPrice || Number.MIN_VALUE, this.lastPriceHigh || Number.MIN_VALUE);

					if (derivedPrice === Number.MIN_VALUE) {
						derivedPrice = null;
					}

					return derivedPrice;
				},
				set: (value) => {
					if (highPrice !== value) {
						highPrice = value;
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'lowPrice', {
				get: () => {
					let derivedPrice = Math.min(lowPrice || Number.MAX_VALUE, this.lastPriceLow || Number.MAX_VALUE);

					if (derivedPrice === Number.MAX_VALUE) {
						derivedPrice = null;
					}

					return derivedPrice;
				},
				set: (value) => {
					if (lowPrice !== value) {
						lowPrice = value;
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'previousPreviousPrice', {
				get: () => {
					return previousPreviousPrice;
				},
				set: (value) => {
					if (previousPreviousPrice !== value) {
						previousPreviousPrice = value;

						calculatePriceChangeForYesterday(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'previousSettlementPrice', {
				get: () => {
					return previousSettlementPrice;
				},
				set: (value) => {
					if (previousSettlementPrice !== value) {
						previousSettlementPrice = value;

						calculatePriceChangeForYesterday(this);
					}
				},
				enumerable: true
			});

			Object.defineProperty(this, 'timeDateDisplay', {
				get: () => {
					return timeDateDisplay;
				},
				set: (value) => {
					let shortDisplay;
					let longDisplay;

					if (value) {
						const d = parseDate(value);

						shortDisplay = value;
						longDisplay = formatLongDate(d);
					} else {
						shortDisplay = null;
						longDisplay = null;
					}

					timeDateDisplay = shortDisplay;

					this.timeDateDisplayLong = longDisplay;
				},
				enumerable: true
			});

			Object.defineProperty(this, 'sessionDateDisplay', {
				get: () => {
					return sessionDateDisplay;
				},
				set: (value) => {
					let longDisplay;

					if (value) {
						const d = parseDate(value);

						longDisplay = formatLongDate(d);
					} else {
						longDisplay = null;
					}

					this.sessionDateDisplayLong = longDisplay;
				},
				enumerable: true
			});

			Object.defineProperty(this, 'previousTimeDateDisplay', {
				get: () => {
					return previousTimeDateDisplay;
				},
				set: (value) => {
					let shortDisplay;
					let longDisplay;

					if (value) {
						const d = parseDate(value);

						shortDisplay = value;
						longDisplay = formatLongDate(d);
					} else {
						shortDisplay = null;
						longDisplay = null;
					}

					previousTimeDateDisplay = shortDisplay;

					this.previousTimeDateDisplayLong = longDisplay;
				},
				enumerable: true
			});
		}

		static getIsInitialized(quote) {
			return typeof(quote.mode) === 'string';
		}

		toString() {
			return `[Quote (description: ${this.symbol})]`;
		}
	}

	const dateRegex = /([0-1][0-9])\/([0-3][0-9])\/([0-9]{2})/;

	function calculateTodayPrice(quote) {
		let todayPrice;

		if (quote.flag === 's' && quote.mode !== 'D') {
			todayPrice = quote.settlementPrice;
		} else {
			todayPrice = quote.lastPrice;
		}

		quote.todayPrice = todayPrice;
	}

	function calculatePriceChange(currentPrice, basePrice, changeAssignment, percentAssignment) {
		let priceChange = null;
		let percentChange = null;

		if (currentPrice !== null && basePrice !== null) {
			priceChange = currentPrice - basePrice;

			if (basePrice !== 0) {
				percentChange = priceChange / basePrice;
			}
		}

		changeAssignment(priceChange);
		percentAssignment(percentChange);
	}

	function calculatePriceChangeForYesterday(quote) {
		calculatePriceChange(quote.previousSettlementPrice, quote.previousPreviousPrice, priceChange => quote.previousPriceChange = priceChange, percentChange => quote.previousPercentChange = percentChange);
	}

	function calculatePriceChangeForToday(quote) {
		calculatePriceChange(quote.todayPrice, quote.previousPrice, priceChange => quote.priceChange = priceChange, percentChange => quote.percentChange = percentChange);
	}

	function calculatePriceChangeForPremarket(quote) {
		calculatePriceChange(quote.premarketPrice, quote.previousPrice, priceChange => quote.premarketPriceChange = priceChange, percentChange => quote.premarketPercentChange = percentChange);
	}

	function calculatePriceChangeForPostmarket(quote) {
		calculatePriceChange(quote.postmarketPrice, quote.todayPrice, priceChange => quote.postmarketPriceChange = priceChange, percentChange => quote.postmarketPercentChange = percentChange);
	}

	function calculatePriceVol(quote) {
		let priceVol;

		if (quote.lastPrice && quote.volume) {
			priceVol = quote.lastPrice * quote.volume;
		} else {
			priceVol = null;
		}

		quote.priceVol = priceVol;
	}

	function calculateState(quote) {
		let state;

		if (quote.sessionT && is.null(quote.flag)) {
			state = 's';
		} else {
			state = quote.flag;
		}

		quote.state = state;
	}

	function calculateActiveStatus(quote) {
		quote.active = is.null(quote.flag) || quote.session === 'T';
	}

	function parseDate(date) {
		const match = date.match(dateRegex);

		if (match && match.length === 4) {
			return new Date(Number.parseInt(match[3]) + 2000, (Number.parseInt(match[1]) - 1), Number.parseInt(match[2]));
		} else {
			return null;
		}
	}

	function formatLongDate(d) {
		return `${dateUtilities.getShortDay(d)}, ${dateUtilities.getShortMonth(d)} ${dateUtilities.getDate(d)}${dateUtilities.getDateOrdinal(d)}, ${dateUtilities.getYear(d)}`;
	}

	return Quote;
})();

