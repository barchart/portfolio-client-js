const utilities = require('barchart-marketdata-utilities');

const assert = require('common/lang/assert'),
	timezone = require('common/lang/timezone');

const Book = require('./Book'),
	Exchange = require('./Exchange'),
	Profile = require('./Profile'),
	Quote = require('./Quote'),
	Timestamp = require('./Timestamp');

module.exports = (() => {
	'use strict';

	/**
	 * The cache maintained by a {@link Connection} instance. This cache is
	 * exposed to consumers via the {@link Connection#getMarketState} function.
	 *
	 * @public
	 */
	class MarketState {
		constructor(connection) {
			this._connection = connection;

			this._symbols = {};
			this._exchanges = {};

			this._timestamp = new Timestamp();
			this._timezoneName = null;
		}

		/**
		 * Sets a default timezone, used by {@link Profile} instances to format dates and times.
		 *
		 * @public
		 * @param {String|null} timezoneName=null - Must conform to a moment.js timezone name (e.g. "America/Chicago" or "America/New_York"). Use null to reset all profiles to their default timezones.
		 * @returns {Boolean} - True if the operation succeeded; false if the timezoneName was invalid (and no change was made).
		 */
		setDefaultTimezoneName(timezoneName) {
			assert.argumentIsOptional(timezoneName, 'timezoneName', String);

			const valid = timezoneName !== null || timezone.hasTimezone(timezoneName);

			if (valid) {
				this._timezoneName = timezoneName;

				const symbols = Object.keys(this._symbols);

				symbols.forEach((symbol) => {
					this._symbols[symbol].profile.timezoneName = this._timezoneName;
				});
			}

			return valid;
		}

		/**
		 * Gets a default timezone, used by {@link Profile} instances to format dates and times.
		 *
		 * @public
		 * @returns {String|null}
		 */
		getDefaultTimezoneName() {
			return this._timezoneName;
		}

		/**
		 * Retrieves the {@link Profile} instance for the symbol. The instance returns
		 * synchronously; however, it may not be populated with data from the server
		 * (see {@link Profile#getIsInitialized}).
		 *
		 * @param {string} symbol - The symbol of the profile to retrieve.
		 * @returns {Profile}
		 */
		getProfile(symbol) {
			return getOrCreateSymbolData.call(this, utilities.symbolFormatter.format(symbol)).profile;
		}

		/**
		 * Retrieves the {@link Quote} instance for the symbol. The instance returns
		 * synchronously; however, it may not be populated with data from the server
		 * (see {@link Quote.getIsInitialized}).
		 *
		 * @public
		 * @param {string} symbol - The symbol of the quote to retrieve.
		 * @param {Boolean=} realtime - If true, the "realtime" quote is retrieved; otherwise, the delayed quote is retreived.
		 * @returns {Quote}
		 */
		getQuote(symbol, realtime) {
			const data = getOrCreateSymbolData.call(this, utilities.symbolFormatter.format(symbol));

			if (realtime) {
				return data.realtime;
			} else {
				return data.quote;
			}
		}

		/**
		 * Retrieves the {@link Book} instance for the symbol. The instance returns
		 * synchronously; however, it may not be populated with data from the server.
		 *
		 * @public
		 * @param {string} symbol - The symbol of the book to retrieve.
		 * @returns {Book}
		 */
		getBook(symbol) {
			return getOrCreateSymbolData.call(this, utilities.symbolFormatter.format(symbol)).book;
		}

		/**
		 * Retrieves the {@link Exchange} instance for an exchange code. The instance
		 * returns synchronously; however, it may not be populated with data from the
		 * server (see {@link Exchange#getIsInitialized}).
		 *
		 * @public
		 * @param {string} code - The code of the exchange to retrieve.
		 * @returns {Exchange}
		 */
		getExchange(code) {
			return getOrCreateExchangeData.call(this, code);
		}

		/**
		 * Returns a promise that is fulfilled; once an exchange data has been
		 * retrieved from the server.
		 *
		 * @public
		 * @param {string} code - The code of the exchange to retrieve.
		 * @returns {Promise<Exchange>}
		 */
		lookupExchange(code) {
			const existing = this.getExchange(code);

			let returnRef;

			if (existing.getIsInitialized()) {
				returnRef = Promise.resolve(existing);
			} else {
				returnRef = this._connection.request('exchangeStatus', {exchange: code})
					.then((data) => {
						const exchange = this.getExchange(code);

						for (let p in data) {
							if (p !== 'code') {
								const value = data[p];

								exchange[p] = value;
							}
						}

						return exchange;
					});
			}

			return returnRef;
		}

		/**
		 * An undocumented function (subject to removal).
		 *
		 * @public
		 * @ignore
		 * @param {String} symbol
		 * @returns {Object}
		 */
		lookupChartSymbol(symbol) {
			return Promise.resolve()
				.then(() => {
					assert.argumentIsRequired('symbol', symbol, String);

					if (symbol.length === 0) {
						throw new Error('The "symbol" argument cannot be a zero-length string.');
					}

					return this._connection.request('chart', { symbol: symbol });
				});
		}

		/**
		 * Indicates if a symbol exists in the internal cache.
		 *
		 * @public
		 * @param symbol - The symbol to lookup.
		 * @returns {boolean}
		 */
		hasSymbol(symbol) {
			return this._symbols.hasOwnProperty(symbol);
		}

		/**
		 * Clears the entire internal cache.
		 *
		 * @ignore
		 */
		dropSymbols() {
			this._symbols = {};
		}

		/**
		 * Removes a single symbol from the internal cache.
		 *
		 * @ignore
		 * @param {string} symbol - The symbol to delete.
		 */
		dropSymbol(symbol) {
			delete this._symbols[symbol];
		}

		/**
		 * Returns the latest timestamp emitted by the server.
		 *
		 * @public
		 * @returns {string|null}
		 */
		getTimestamp() {
			return this._timestamp.timestamp;
		}

		toString() {
			return '[MarketState]';
		}
	}

	function getOrCreateSymbolData(symbol) {
		if (!this._symbols[symbol]) {
			const book = new Book(symbol);
			const profile = new Profile(symbol);
			const delayed = new Quote(symbol);
			const realtime = new Quote(symbol);

			profile.timezoneName = this.getDefaultTimezoneName();

			this._symbols[symbol] = {
				book: book,
				profile: profile,
				quote: delayed,
				realtime: realtime
			};
		}

		return this._symbols[symbol];
	}

	function getOrCreateExchangeData(code) {
		if (!this._exchanges[code]) {
			this._exchanges[code] = new Exchange(code);
		}

		return this._exchanges[code];
	}

	return MarketState;
})();

