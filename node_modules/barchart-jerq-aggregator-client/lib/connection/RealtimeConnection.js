const EventMap = require('common/messaging/EventMap'),
	is = require('common/lang/is');

const Connection = require('./Connection');

const Exchange = require('./../market/Exchange'),
	MarketState = require('./../market/MarketState'),
	Quote = require('./../market/Quote');

module.exports = (() => {
	'use strict';

	class RealtimeConnection extends Connection {
		constructor(connection) {
			super();

			this._connection = connection;
			this._marketState = new RealtimeMarketState(connection);

			this._bats = null;

			this._marketPriceEventMap = new EventMap();
			this._marketPriceHandler = getMarketPriceHandler.call(this);

			this._connectPromise = null;
		}

		connect(host, secure, port) {
			if (this._connectPromise === null) {
				this._connectPromise = this._connection.connect(host || this._connection.getHost(), secure || this._connection.getIsSecure(), port || this._connection.getPort())
					.then(() => {
						const handleBatsStatus = (e) => {
							this._bats = e;

							const marketState = this._connection.getMarketState();

							this._marketPriceEventMap.getKeys().forEach((symbol) => {
								const composite = getCompositeQuote(marketState, symbol);
								const realtime = getRealtimeQuote(marketState, symbol);
								const delayed = getDelayedQuote(marketState, symbol);
								const recent = selectMostRecentFeed(delayed, realtime);

								if (synchronizeFlag(composite, delayed, realtime, recent, this._bats) && Quote.getIsInitialized(composite)) {
									this._marketPriceEventMap.fire(symbol, composite);
								}
							});
						};

						this._connection.on('exchangeStatus', handleBatsStatus, Exchange.getBatsCode());
					}).then(() => {
						return this;
					});
			}

			return this._connectPromise;
		}

		disconnect() {
			return this._connection.disconnect()
				.then(() => {
					this._marketPriceEventMap.dispose();
					this._marketPriceEventMap = new EventMap();

					this._connectPromise = null;

					return this;
				});
		}

		on(event, eventHandler) {
			this.connect().then(() => {
				if (event === 'marketPriceChange') {
					const symbols = Connection.getSymbols(arguments);

					const symbolsToSubscribe = symbols.reduce((symbols, symbol) => {
						this._marketPriceEventMap.register(symbol, eventHandler);

						symbols.push(symbol);
						symbols.push(getRealtimeSymbol(symbol));

						return symbols;
					}, [ ]);

					if (symbolsToSubscribe.length !== 0) {
						this._connection.on.apply(this._connection, [ 'marketPriceChange', this._marketPriceHandler ].concat(symbolsToSubscribe));
					}

					symbols.forEach((symbol) => {
						const quote = this._marketState.getQuote(symbol, true);

						if (Quote.getIsInitialized(quote)) {
							eventHandler(quote);
						}
					});
				} else {
					this._connection.on.apply(this._connection, arguments);
				}
			});
		}

		off(event, eventHandler) {
			this.connect().then(() => {
				if (event === 'marketPriceChange') {
					const symbols = Connection.getSymbols(arguments);

					const symbolsToUnsubscribe = symbols.reduce((symbols, symbol) => {
						this._marketPriceEventMap.unregister(symbol, eventHandler);

						if (!this._marketPriceEventMap.hasKey(symbol)) {
							symbols.push(symbol);
							symbols.push(getRealtimeSymbol(symbol));
						}

						return symbols;
					}, [ ]);

					if (symbolsToUnsubscribe.length !== 0) {
						this._connection.off.apply(this._connection, [ 'marketPriceChange', this._marketPriceHandler ].concat(symbolsToUnsubscribe));

						symbolsToUnsubscribe.forEach((symbol) => {
							if (this.getSubscribed(symbol)) {
								this._marketState.dropSymbol(symbol);
							}
						});
					}
				} else {
					this._connection.on.apply(this._connection, arguments);
				}
			});
		}

		request(requestType, requestData) {
			this.connect().then(() => {
				return this._connection.request(requestType, requestData);
			});
		}

		getSubscribed(symbol) {
			return this._connection.getSubscribed(symbol);
		}

		getHost() {
			return this._connection.getHost();
		}

		getPort() {
			return this._connection.getPort();
		}

		getConnectionState() {
			return this._connection.getConnectionState();
		}

		getMarketState() {
			return this._marketState;
		}

		getSubscriptionStatus() {
			return this._connection.getSubscriptionStatus();
		}

		getServerVersion() {
			return this._connection.getServerVersion();
		}

		getRealtime() {
			return this;
		}

		toString() {
			return '[RealtimeConnection]';
		}
	}

	function getMarketPriceHandler() {
		return (snapshot) => {
			let symbol = snapshot.symbol;

			if (getIsRealtimeSymbol(symbol)) {
				symbol = getDelayedSymbol(symbol);
			}

			if (!this._marketState.hasSymbol(symbol)) {
				return;
			}

			const marketState = this._connection.getMarketState();

			const realtime = getRealtimeQuote(marketState, symbol);
			const delayed = getDelayedQuote(marketState, symbol);

			let quote;

			if (Quote.getIsInitialized(realtime)) {
				const composite = getCompositeQuote(marketState, symbol);
				const recent = selectMostRecentFeed(delayed, realtime);

				for (let p in snapshot) {
					if (p !== 'symbol') {
						const synchronizer = synchronizers[p];

						if (synchronizer) {
							synchronizer(composite, delayed, realtime, recent, this._bats);
						}
					}
				}

				quote = composite;
			} else {
				quote = delayed;
			}

			if (Quote.getIsInitialized(delayed)) {
				this._marketPriceEventMap.fire(symbol, quote);
			}
		};
	}

	function getIsRealtimeSymbol(symbol) {
		return symbol.length > 2 && symbol.substr(symbol.length - 3, 3) === '.BZ';
	}

	function getRealtimeSymbol(symbol) {
		return symbol + '.BZ';
	}

	function getDelayedSymbol(symbol) {
		return symbol.substring(0, symbol.length - 3);
	}

	function getCompositeQuote(marketState, symbol) {
		return marketState.getQuote(symbol, true);
	}

	function getRealtimeQuote(marketState, symbol) {
		return marketState.getQuote(getRealtimeSymbol(symbol), false);
	}

	function getDelayedQuote(marketState, symbol) {
		return marketState.getQuote(symbol, false);
	}

	function selectInitializedFeed(delayed, realtime) {
		let returnRef;

		if (Quote.getIsInitialized(realtime)) {
			returnRef = realtime;
		} else {
			returnRef = delayed;
		}

		return returnRef;
	}

	function selectMostRecentFeed(delayed, realtime) {
		let returnRef;

		if (Quote.getIsInitialized(delayed) && Quote.getIsInitialized(realtime) && realtime.time && delayed.time) {
			if (delayed.time > realtime.time) {
				returnRef = delayed;
			} else {
				returnRef = realtime;
			}
		} else {
			returnRef = selectInitializedFeed(delayed, realtime);
		}

		return returnRef;
	}

	function synchronizeProperty(target, source, property) {
		const returnVal = target[property] !== source[property];

		if (returnVal) {
			target[property] = source[property];
		}

		return returnVal;
	}

	function getDefaultSynchronizer(property) {
		return (target, delayed, realtime, recent, exchange) => {
			const source = selectInitializedFeed(delayed, realtime);

			return synchronizeProperty(target, source, property);
		};
	}

	function getRecentSynchronizer(property) {
		return (target, delayed, realtime, recent, exchange) => {
			return synchronizeProperty(target, recent, property);
		};
	}

	function getDelayedSynchronizer(property) {
		return (target, delayed, realtime, recent, exchange) => {
			return synchronizeProperty(target, delayed, property);
		};
	}

	function synchronizeLowPrice(target, delayed, realtime, recent, exchange) {
		let lowPrice = Math.min(delayed.lowPrice || Number.MAX_VALUE, realtime.lowPrice || Number.MAX_VALUE);

		if (lowPrice === Number.MAX_VALUE) {
			lowPrice = null;
		}

		const returnVal = target.lowPrice !== lowPrice;

		if (returnVal) {
			target.lowPrice = lowPrice;
		}

		return returnVal;
	}

	function synchronizeHighPrice(target, delayed, realtime, recent, exchange) {
		let highPrice = Math.max(delayed.highPrice || Number.MIN_VALUE, realtime.highPrice || Number.MIN_VALUE);

		if (highPrice === Number.MIN_VALUE) {
			highPrice = null;
		}

		const returnVal = target.highPrice !== highPrice;

		if (returnVal) {
			target.highPrice = highPrice;
		}

		return returnVal;
	}

	function synchronizeLastPrice(target, delayed, realtime, recent, exchange) {
		const returnVal = synchronizeProperty(target, recent, 'lastPrice');

		if (returnVal) {
			synchronizeLowPrice(target, delayed, realtime, recent, exchange);
			synchronizeHighPrice(target, delayed, realtime, recent, exchange);
		}

		return returnVal;
	}

	function synchronizeSettlementPrice(target, delayed, realtime, recent, exchange) {
		let source;

		if (delayed.flag === 's') {
			source = delayed;
		} else {
			source = realtime;
		}

		return synchronizeProperty(target, source, 'settlementPrice');
	}

	function synchronizeMarket(target, delayed, realtime, recent, exchange, propertyName) {
		let source;

		const d = delayed[propertyName];
		const r = realtime[propertyName];

		let open;

		if (exchange && exchange.getIsOpen()) {
			open = true;
		} else {
			open = false;
		}

		if (!Quote.getIsInitialized(realtime) || !Quote.getIsInitialized(delayed)) {
			source = selectInitializedFeed(delayed, realtime);
		} else if (open && !d) {
			source = delayed;
		} else if (open && !r) {
			source = realtime;
		} else if (!open && d === 'p') {
			source = delayed;
		} else if (!d && r === 'p') {
			source = delayed;
		} else if (d === 's') {
			synchronizeSettlementPrice(target, delayed, realtime, exchange);

			source = delayed;
		} else {
			source = realtime;
		}

		return synchronizeProperty(target, source, propertyName);
	}

	function synchronizeFlag(target, delayed, realtime, recent, exchange) {
		synchronizeMarket(target, delayed, realtime, recent, exchange, 'flag');
	}

	function synchronizeState(target, delayed, realtime, recent, exchange) {
		synchronizeMarket(target, delayed, realtime, recent, exchange, 'state');
	}

	function synchronizeIgnoredProperty(target, delayed, realtime, recent, exchange) {
		return true;
	}

	const synchronizers = (() => {
		const returnRef = {
			volume: getDelayedSynchronizer('volume'),
			numberOfTrades: getDelayedSynchronizer('numberOfTrades'),
			previousPrice: getDelayedSynchronizer('previousPrice'),
			previousPreviousPrice: getDelayedSynchronizer('previousPreviousPrice'),
			previousOpenPrice: getDelayedSynchronizer('previousOpenPrice'),
			previousHighPrice: getDelayedSynchronizer('previousHighPrice'),
			previousLowPrice: getDelayedSynchronizer('previousLowPrice'),
			previousSettlementPrice: getDelayedSynchronizer('previousSettlementPrice'),
			openPrice: getDelayedSynchronizer('openPrice'),

			mode: getRecentSynchronizer('mode'),
			lastPriceT: getRecentSynchronizer('lastPriceT'),
			bidPrice: getRecentSynchronizer('bidPrice'),
			bidSize: getRecentSynchronizer('bidSize'),
			askPrice: getRecentSynchronizer('askPrice'),
			askSize: getRecentSynchronizer('askSize'),
			tradePrice: getRecentSynchronizer('tradePrice'),
			tradeSize: getRecentSynchronizer('tradeSize'),
			time: getRecentSynchronizer('time'),
			timeActual: getRecentSynchronizer('timeActual'),
			timeDisplay: getRecentSynchronizer('timeDisplay'),
			tradeTime: getRecentSynchronizer('tradeTime'),
			tradeTimeActual: getRecentSynchronizer('tradeTimeActual'),
			tradeTimeDisplay: getRecentSynchronizer('tradeTimeDisplay'),

			lowPrice: synchronizeLowPrice,
			highPrice: synchronizeHighPrice,
			lastPrice: synchronizeLastPrice,
			settlementPrice: synchronizeSettlementPrice,
			flag: synchronizeFlag,
			state: synchronizeState,

			lastPriceDirection: synchronizeIgnoredProperty,
			priceChange: synchronizeIgnoredProperty,
			percentChange: synchronizeIgnoredProperty,
			postmarketPrice: synchronizeIgnoredProperty,
			postmarketPriceChange: synchronizeIgnoredProperty,
			postmarketPercentChange: synchronizeIgnoredProperty,
			previousPriceChange: synchronizeIgnoredProperty,
			previousPercentChange: synchronizeIgnoredProperty
		};

		const quote = new Quote('');

		for (let p in quote) {
			if (!returnRef.hasOwnProperty(p)) {
				returnRef[p] = getDefaultSynchronizer(p);
			}
		}

		return returnRef;
	})();

	class RealtimeMarketState extends MarketState {
		constructor(connection) {
			super();

			this._wrapped = connection.getMarketState();
		}

		setDefaultTimezone(timezoneName) {
			return this._wrapped.setDefaultTimezone(timezoneName);
		}

		getDefaultTimezone() {
			return this._wrapped.getDefaultTimezone();
		}

		getProfile(symbol) {
			return this._wrapped.getProfile(symbol);
		}

		getQuote(symbol, realtime) {
			return this._wrapped.getQuote(symbol, true);
		}

		getBook(symbol) {
			return this._wrapped.getBook(symbol);
		}

		getExchange(code) {
			return this._wrapped.getExchange(code);
		}

		lookupExchange(code) {
			return this._wrapped.lookupExchange(code);
		}

		hasSymbol(symbol) {
			return this._wrapped.hasSymbol(symbol);
		}

		dropSymbols() {
			this._wrapped.dropSymbols();
		}

		dropSymbol(symbol) {
			this._wrapped.dropSymbol(symbol);
		}

		getTimestamp() {
			return this._wrapped.getTimestamp();
		}

		toString() {
			return '[RealtimeMarketState]';
		}
	}

	return RealtimeConnection;
})();