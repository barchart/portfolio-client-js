const io = require('socket.io-client'),
	uuid = require('uuid');

const array = require('common/lang/array'),
	cu = require('common/lang/connection'),
	Event = require('common/messaging/Event'),
	EventMap = require('common/messaging/EventMap'),
	is = require('common/lang/is'),
	promise = require('common/lang/promise');

const Connection = require('./Connection'),
	ConnectionState = require('./ConnectionState'),
	RealtimeConnection = require('./RealtimeConnection');

const MarketState = require('../market/MarketState'),
	Quote = require('../market/Quote');

module.exports = (() => {
	'use strict';

	class SocketIOConnection extends Connection {
		constructor() {
			super();

			this._marketState = new MarketState(this);

			this._host = null;
			this._port = null;
			this._secure = null;

			this._socket = null;

			this._realtimeConnection = null;

			this._connectionEvent = new Event(this);
			this._connectionState = ConnectionState.Disconnected;
			this._connectPromise = null;

			this._timestampEvent = new Event(this);

			this._marketUpdateEventMap = new EventMap(this);
			this._marketPriceEventMap = new EventMap(this);
			this._marketDepthEventMap = new EventMap(this);
			this._profileChangeEventMap = new EventMap(this);
			this._exchangeChangeEventMap = new EventMap(this);

			this._requestMap = {};
		}

		connect(host, secure, port) {
			if (this._connectPromise === null) {
				const secureToUse = cu.getIsSecure(secure);

				let protocol;

				if (secureToUse) {
					protocol = 'https';
				} else {
					protocol = 'http';
				}

				let portToUse;

				if (is.number(port)) {
					portToUse = port;
				} else {
					if (secureToUse) {
						portToUse = 443;
					} else {
						portToUse = 80;
					}
				}

				this._host = host || 'jerq-aggregator-prod.aws.barchart.com';
				this._port = portToUse;
				this._secure = secureToUse;

				this._connectPromise = promise.build((resolveCallback) => {
					this._socket = io.connect(`${protocol}://${this._host}:${portToUse}`, {
						transports: ['websocket'],
						secure: secureToUse,
						forceNew: true
					});

					this._socket.on('connect', () => {
						changeConnectionState.call(this, ConnectionState.Connected);

						resolveCallback(this._marketState);
					});

					this._socket.on('reconnecting', () => {
						changeConnectionState.call(this, ConnectionState.Connecting);
					});

					this._socket.on('reconnect', () => {
						changeConnectionState.call(this, ConnectionState.Connected);

						if (this._timestampEvent.getIsEmpty()) {
							sendToServer.call(this, 'unsubscribe/timestamp', {});
						} else {
							sendToServer.call(this, 'subscribe/timestamp', {});
						}

						const marketUpdateSymbols = this._marketUpdateEventMap.getKeys();

						if (marketUpdateSymbols.length > 0) {
							sendToServer.call(this, 'subscribe/symbols', { symbols: marketUpdateSymbols, subscribeToQuotes: true });
						}

						const marketPriceSymbols = this._marketPriceEventMap.getKeys();

						if (marketPriceSymbols.length > 0) {
							sendToServer.call(this, 'subscribe/symbols', { symbols: marketPriceSymbols, subscribeToPrices: true });
						}

						const marketDepthSymbols = this._marketDepthEventMap.getKeys();

						if (marketDepthSymbols.length > 0) {
							sendToServer.call(this, 'subscribe/symbols', { symbols: marketDepthSymbols, subscribeToBook: true });
						}

						const exchangeCodes = this._exchangeChangeEventMap.getKeys();

						if (exchangeCodes.length > 0) {
							sendToServer.call(this, 'subscribe/exchanges', { codes: exchangeCodes });
						}
					});

					const updateProfile = (data) => {
						const profile = this._marketState.getProfile(data.symbol);

						for (let p in data) {
							if (p !== 'symbol') {
								let value = data[p];

								profile[p] = value;
							}
						}

						return profile;
					};

					const updateQuote = (data) => {
						const quote = this._marketState.getQuote(data.symbol);

						for (let p in data) {
							if (p !== 'symbol') {
								const value = data[p];

								quote[p] = value;
							}
						}

						return quote;
					};

					const updateBook = (data) => {
						const book = this._marketState.getBook(data.symbol);

						for (let p in data) {
							if (p !== 'symbol') {
								const value = data[p];

								book[p] = value;
							}
						}

						return book;
					};

					const updateExchange = (data) => {
						const exchange = this._marketState.getExchange(data.code);

						for (let p in data) {
							if (p !== 'code') {
								const value = data[p];

								exchange[p] = value;
							}
						}

						return exchange;
					};

					this._socket.on('profile/snapshot', (snapshot) => {
						if (this._marketState.hasSymbol(snapshot.symbol)) {
							const profile = updateProfile(snapshot);

							this._profileChangeEventMap.fire(profile.symbol, profile);
						}
					});

					this._socket.on('quote/snapshot', (snapshot) => {
						if (this._marketState.hasSymbol(snapshot.symbol)) {
							const quote = updateQuote(snapshot);

							this._marketPriceEventMap.fire(quote.symbol, quote);
							this._marketUpdateEventMap.fire(quote.symbol, quote);
						}
					});

					this._socket.on('quote/delta', (delta) => {
						if (this._marketState.hasSymbol(delta.symbol)) {
							const quote = updateQuote(delta);

							// 2016/07/13, BRI. This is gross. The Quote object should
							// inherit Model (i.e. common/models/Model), which provides
							// delta objects natively. This inference violates separation
							// of concerns.

							if (delta.hasOwnProperty('lastPrice') || delta.hasOwnProperty('previousPrice') || delta.hasOwnProperty('settlementPrice')) {
								delta.priceChange = quote.priceChange;
								delta.percentChange = quote.percentChange;
							}

							if (delta.hasOwnProperty('lastPrice') || delta.hasOwnProperty('settlementPrice')) {
								delta.settlementPriceChange = quote.settlementPriceChange;
								delta.settlementPercentChange = quote.settlementPercentChange;
							}

							if (delta.hasOwnProperty('lastPrice') || delta.hasOwnProperty('volume')) {
								delta.priceVol = quote.priceVol;
							}

							if (delta.hasOwnProperty('previousPreviousPrice') || delta.hasOwnProperty('previousSettlementPrice')) {
								delta.previousPriceChange = quote.previousPriceChange;
								delta.previousPercentChange = quote.previousPercentChange;
							}

							this._marketUpdateEventMap.fire(quote.symbol, delta);
						}
					});

					this._socket.on('book/snapshot', (snapshot) => {
						if (this._marketState.hasSymbol(snapshot.symbol)) {
							const book = updateBook(snapshot);

							this._marketDepthEventMap.fire(book.symbol, book);
						}
					});

					this._socket.on('exchange/snapshot', (snapshot) => {
						const exchange = updateExchange(snapshot);

						this._exchangeChangeEventMap.fire(exchange.code, exchange);
					});

					this._socket.on('timestamp', (data) => {
						this._timestampEvent.fire(data.timestamp);
					});

					this._socket.on('response', (data) => {
						const requestId = data.requestId;

						if (requestId) {
							const rc = this._requestMap[requestId];

							if (rc) {
								delete this._requestMap[requestId];

								rc(data.response);
							}
						}
					});
				});
			}

			return this._connectPromise;
		}

		disconnect() {
			if (!this.getConnectionState().getCanDisconnect()) {
				return;
			}

			return promise.build((resolveCallback) => {
				changeConnectionState.call(this, ConnectionState.Disconnecting);

				this._socket.on('disconnect', () => {
					this._socket = null;

					this._marketState.dropSymbols();

					this._marketUpdateEventMap.dispose();
					this._marketPriceEventMap.dispose();
					this._marketDepthEventMap.dispose();
					this._profileChangeEventMap.dispose();
					this._exchangeChangeEventMap.dispose();

					this._marketUpdateEventMap = new EventMap(this);
					this._marketPriceEventMap = new EventMap(this);
					this._marketDepthEventMap = new EventMap(this);
					this._profileChangeEventMap = new EventMap(this);
					this._exchangeChangeEventMap = new EventMap(this);

					this._requestMap = {};
					this._connectPromise = null;

					changeConnectionState.call(this, ConnectionState.Disconnected);

					resolveCallback(this);
				});

				this._socket.disconnect();
			});
		}

		on(event, eventHandler) {
			const symbols = Connection.getSymbols(arguments);

			const initializeQuotes = () => {
				symbols.forEach((symbol) => {
					const quote = this._marketState.getQuote(symbol);

					if (Quote.getIsInitialized(quote)) {
						eventHandler(quote);
					}
				});
			};

			const subscribeToSymbols = (map, message) => {
				const symbolsToSubscribe = array.unique(
					symbols.filter((symbol) => {
						const returnVal = map.getIsEmpty(symbol);

						map.register(symbol, eventHandler);

						return returnVal;
					})
				);

				if (symbolsToSubscribe.length > 0) {
					message.symbols = symbolsToSubscribe;

					sendToServer.call(this, 'subscribe/symbols', message);
				}
			};

			switch (event) {
				case 'connectionStateChange':
				{
					this._connectionEvent.register(eventHandler);

					break;
				}
				case 'timestamp':
				{
					this._timestampEvent.register(eventHandler);

					sendToServer.call(this, 'subscribe/timestamp', {});

					break;
				}
				case 'profileChange':
				{
					symbols.forEach((symbol) => {
						this._profileChangeEventMap.register(symbol, eventHandler);
					});

					break;
				}
				case 'marketPriceChange':
				{
					subscribeToSymbols(this._marketPriceEventMap, { subscribeToPrices: true });

					initializeQuotes();

					break;
				}
				case 'marketUpdate':
				{
					subscribeToSymbols(this._marketUpdateEventMap, { subscribeToQuotes: true });

					initializeQuotes();

					break;
				}
				case 'marketDepth':
				{
					subscribeToSymbols(this._marketDepthEventMap, { subscribeToBook: true });

					break;
				}
				case 'exchangeStatus':
				{
					symbols.forEach((code) => {
						this._exchangeChangeEventMap.register(code, eventHandler);
					});

					sendToServer.call(this, 'subscribe/exchanges', { codes: symbols });

					break;
				}
				default:
				{
					break;
				}
			}
		}

		off(event, eventHandler) {
			const symbols = Connection.getSymbols(arguments);

			const unsubscribeFromSymbols = (map, message) => {
				const symbolsToUnsubscribe = array.unique(
					symbols.filter((symbol) => {
						map.unregister(symbol, eventHandler);

						return map.getIsEmpty(symbol);
					})
				);

				if (symbolsToUnsubscribe.length > 0) {
					message.symbols = symbolsToUnsubscribe;

					sendToServer.call(this, 'subscribe/symbols', message);

					symbolsToUnsubscribe.forEach((symbol) => {
						if (!this.getSubscribed(symbol)) {
							this._marketState.dropSymbol(symbol);
						}
					});
				}
			};

			switch (event) {
				case 'connectionStateChange':
				{
					this._connectionEvent.unregister(eventHandler);

					break;
				}
				case 'timestamp':
				{
					this._timestampEvent.unregister(eventHandler);

					if (this._timestampEvent.getIsEmpty()) {
						sendToServer.call(this, 'unsubscribe/timestamp', {});
					}

					break;
				}
				case 'profileChange':
				{
					symbols.forEach((symbol) => {
						this._profileChangeEventMap.unregister(symbol, eventHandler);
					});

					break;
				}
				case 'marketPriceChange':
				{
					unsubscribeFromSymbols(this._marketPriceEventMap, { subscribeToPrices: false });

					break;
				}
				case 'marketUpdate':
				{
					unsubscribeFromSymbols(this._marketUpdateEventMap, { subscribeToQuotes: false });

					break;
				}
				case 'marketDepth':
				{
					unsubscribeFromSymbols(this._marketDepthEventMap, { subscribeToBook: false });

					break;
				}
				case 'exchangeStatus':
				{
					const exchangesToUnsubscribe = [];

					symbols.forEach((code) => {
						this._exchangeChangeEventMap.unregister(code, eventHandler);

						if (this._exchangeChangeEventMap.getIsEmpty(code)) {
							exchangesToUnsubscribe.push(code);
						}
					});

					if (exchangesToUnsubscribe.length > 0) {
						sendToServer.call(this, 'unsubscribe/exchanges', {codes: exchangesToUnsubscribe});
					}

					break;
				}
				default:
				{
					break;
				}
			}
		}

		request(requestType, requestData) {
			let requestPromise;

			if (this.getConnectionState().getCanTransmit()) {
				requestPromise = promise.build((resolveCallback) => {
					const requestId = uuid.v4();

					this._requestMap[requestId] = resolveCallback;

					this._socket.emit('request/' + requestType, {requestId: requestId, request: requestData});
				});
			} else {
				requestPromise = Promise.reject(new Error('Unable to request data from server without an active connection.'));
			}

			return requestPromise;
		}

		getSubscribed(symbol) {
			return Connection.getSubscribed(symbol, [ this._marketUpdateEventMap, this._marketPriceEventMap, this._marketDepthEventMap ]);
		}

		getHost() {
			return this._host;
		}

		getIsSecure() {
			return this._secure;
		}

		getPort() {
			return this._port;
		}

		getConnectionState() {
			return this._connectionState;
		}

		getMarketState() {
			return this._marketState;
		}

		getSubscriptionStatus() {
			return this.request('subscriptions', {})
				.then((subscriptions) => {
					return {
						server: {
							price: subscriptions.price.sort(),
							quote: subscriptions.quote.sort(),
							book: subscriptions.book.sort()
						},
						client: {
							price: this._marketPriceEventMap.getKeys().sort(),
							quote: this._marketUpdateEventMap.getKeys().sort(),
							book: this._marketDepthEventMap.getKeys().sort()
						}
					};
				});
		}

		getServerVersion() {
			return this.request('version', {})
				.then((versionData) => {
					return versionData.semver;
				});
		}

		getRealtime() {
			if (this._realtimeConnection === null) {
				this._realtimeConnection = new RealtimeConnection(this);
			}

			return this._realtimeConnection;
		}

		toString() {
			return '[SocketIOConnection]';
		}
	}

	function sendToServer(channel, data) {
		if (this.getConnectionState().getCanTransmit()) {
			this._socket.emit(channel, data);
		}
	}

	function changeConnectionState(connectionState) {
		this._connectionState = connectionState;

		this._connectionEvent.fire(this._connectionState.getDescription());
	}

	return SocketIOConnection;
})();